% To avoid execution of code, do opts_chunk$set(eval = FALSE)
% Or in shell to make NimbleUserManualNoEval.pdf
\documentclass[12pt,oneside]{book}

\usepackage{bbding}
\usepackage[unicode=true]{hyperref}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{verbatim}
\geometry{tmargin = 1in, bmargin = 1in, lmargin = 1in, rmargin = 1in}

\def\file#1{\textsl{#1}}

\def\cd#1{\texttt{#1}}
\def\nm#1{\textit{#1}}
\newcommand{\ver}{0.3}

\hypersetup{colorlinks=true, linkcolor=red}

\begin{document}
%\SweaveOpts{concordance=TRUE}
%\SweaveOpts{concordance=TRUE}

<<setup, include=FALSE, cache=FALSE>>=
## replace.assign replaces "=" with "<-"; 
## width controls (not perfectly) width of R code lines, hopefully avoiding some of the margin overflow
options(replace.assign=TRUE, width=65)
@


\title{NIMBLE User Manual}
\author{NIMBLE Development Team}
\date{Version \ver}
\maketitle

<<chunk0, echo = FALSE>>=
## source the code
require(nimble, warn.conflicts = FALSE, quietly = TRUE)
#source(file.path('..', '..', 'examples', 'demos', 'loadAllCode.R'))
require(methods, warn.conflicts = FALSE, quietly = TRUE)  # seems to be needed, but why?
require(igraph, warn.conflicts = FALSE, quietly = TRUE)  # same question
read_chunk(file.path('chunks', 'introExample_chunks.R'))  # one can put code chunks here if one wants
@ 

\begingroup
\hypersetup{linkcolor=blue}
%\hypersetup{linkcolor=green,pdfborderstyle={/S/U/W 1}}
\tableofcontents
\endgroup

\chapter{Welcome to NIMBLE}
\label{sec:welcome-nimble}

NIMBLE is a system for building and sharing analysis methods for
statistical models, especially for hierarchical models and
computationally-intensive methods.  This is an early version,
\ver. You can do quite a bit with it, but you can also expect it to be rough
and incomplete.  If you want to analyze data, we hope you will find
something already useful.  If you want to build algorithms, we hope
you will program in NIMBLE and make an R package providing your
method.  We also hope you will join the mailing lists
(\href{http://R-nimble.org}{R-nimble.org}) and help improve NIMBLE by
telling us what you want to do with it, what you like, and what could
be better.  We have a lot of ideas for how to improve it, but we want
your help and ideas too.

\section{Why something new?}
\label{sec:why-something-new}

There is a lot of statistical software out there.  Why did we build
something new?  More and more, statistical models are being customized
to the details of each project.  That means it is often difficult to
find a package whose set of available models and methods includes what
you need.  And more and more, statistical models are hierarchical,
meaning they have some unobserved random variables between the
parameters and the data.  These may be random effects, shared
frailties, latent states, or other such things.  Or a model may be
hierarchical simply due to putting Bayesian priors on parameters.
Except for simple cases, hierarchical statistical models are often
analyzed with computationally-intensive algorithms, the best known of
which is Markov chain Monte Carlo (MCMC).

Several existing software systems have become widely used by
providing a flexible way to say what the model is and then
automatically providing an algorithm such as MCMC.  When these work,
and when MCMC is what you want, that's great.  Unfortunately, there
are a lot of hard models out there for which default MCMCs don't work
very well.  And there are also a lot of useful new and old algorithms that
are not MCMC.  That's why we wanted to create a system that combines a
flexible system for model specification -- the BUGS language -- with
the ability to program with those models.  That's the goal of NIMBLE.

\section{What does NIMBLE do?}
\label{sec:what-is-nimble}

NIMBLE stands for Numerical Inference of statistical Models for Bayesian and
Likelihood Estimation.  Although NIMBLE was motivated by algorithms
for hierarchical
statistical models, you could use it for
simpler models too.

You can think of NIMBLE as comprising three pieces:

\begin{enumerate}
\item A system for writing statistical models flexibly, which is an
  extension of the BUGS language\footnote{But see Section
    \ref{sec:not-yet-supported} for information about limitations and
    extensions to how NIMBLE handles BUGS right now.}.
\item A library of algorithms such as MCMC.
\item A language, called NIMBLE, embedded within and similar in style
  to R, for writing algorithms that operate on BUGS models.
\end{enumerate}

Both BUGS models and NIMBLE algorithms are automatically processed
into C++ code, compiled, and loaded back into R with seamless
interfaces.  

Since NIMBLE can compile R-like functions into C++ that use the Eigen
library for fast linear algebra, it can be useful for making fast
numerical functions with or without BUGS models involved\footnote{The
 packages Rcpp and RcppEigen provide different ways of
  connecting C++, the Eigen library and R.  In those packages you
  program directly in C++, while in NIMBLE you program in an R-like
  fashion and the NIMBLE compiler turns it into C++.  Programming
  directly in C++ allows full access to C++, while programming in
  NIMBLE allows simpler code.}

One of the beauties of R is that many of the high-level analysis
functions are themselves written in R, so it is easy to see their code and modify
them.  The same is true for NIMBLE: the algorithms are themselves
written in the NIMBLE language.

\section{How to use this manual}
We emphasize that you can use NIMBLE for data analysis with the
algorithms provided by NIMBLE without ever using the NIMBLE language
to write algorithms. So as you get started, feel free to focus on
Chapters \ref{cha:intro}-\ref{cha:algos-provided}.  The algorithm
library in v\ver\ is just a start, so we hope you'll let us know what
you want to see and consider writing it in NIMBLE.  More about NIMBLE
programming comes in \ref{cha:progr-with-models}.


\chapter{Lightning introduction}
\label{cha:intro}

\section{A brief example}
\label{sec:brief-example}

Here we'll give a simple example of building a model and running some algorithms on the model, as well as creating our own user-specified algorithm. The goal is to give you a sense for what one can do in the system. Later sections will provide more detail.

We'll use the \nm{pump} model example from BUGS\footnote{The data set
  describes failure times of some pumps.}. As you'll see later, we can
read the model into NIMBLE from the files provided as the
BUGS example but for now, we'll enter it directly in R.

In this ``lightning introduction'' we will:

\begin{enumerate}
\item Create the model for the pump example.
\item Compile the model.
\item Create a basic MCMC specification for the pump model.
\item Compile and run the MCMC
\item Customize the MCMC specification and compile and run that.
\item Create, compile and run a Monte Carlo Expectation Maximization (MCEM)
  algorithm, which illustrates some of the flexibility NIMBLE
  provides to combine R and NIMBLE.
\item Write a short \cd{nimbleFunction} to generate simulations from
  designated nodes of any  model.
\end{enumerate}


\section{Creating a model}

First we define the model code, its constants, data, and initial
values for MCMC.

<<inputPump>>=
@ 

Now let's create the model and look at some of its nodes.

<<explorePump>>=
@ 


Notice that
in the list of nodes, NIMBLE has introduced a new node,
\cd{lifted\_d1\_over\_beta}. We call this a ``lifted'' node. Like R,
NIMBLE allows alternative parameterizations, such as the scale or rate
parameterization of the gamma distribution. Choice of parameterization
can generate a lifted node. It's helpful to know why they exist, but you shouldn't need
to worry about them.

Thanks to the plotting capabilities of the \cd{igraph} package that
NIMBLE uses to represent the directed acyclic graph, we can plot the
model  (figure 2.1).

<<plotPump, fig.cap="Directed Acyclic Graph plot of the pump model, thanks to the igraph package">>=
@ 

To simulate from the prior for \cd{theta} (overwriting the initial
values previously in the model) we first need to fully initialize the
model, including any non-stochastic nodes such as lifted nodes.  We do
so using
NIMBLE's \cd{calculate} function and then simulate from the
distribution for \cd{theta}.  First we show how to use the model's
\cd{getDependencies} method to query information about its graph.

<<manipPump>>=
@ 

Notice that the first \cd{getDependencies} call returned dependencies
from \cd{alpha} and \cd{beta} down to the next stochastic nodes in the
model.  The second call requested only deterministic dependencies.
We used this as the second argument to \cd{calculate}.  The call to \cd{calculate(pump, `theta')}
expands \cd{`theta'} to include all nodes in \cd{theta}.  After
simulating into \cd{`theta'}, we make sure to calculate its
dependencies so they are kept up to date with the new \cd{theta} values.

\section{Compiling the model}
\label{sec:compiling-model}

Next we compile the model, which means generating C++ code, compiling
that code, and loading it back into R with an object that can be used just
like the uncompiled model. The values in the compiled model will be
initialized from those of the original model in R, but
the original and compiled models are distinct objects so any
subsequent changes in one will not be reflected in the other.

<<compilePump>>=
@ 


\section{Creating, compiling and running a basic MCMC specification}

At this point we have initial values for all of the nodes in the model
and we have both the original and compiled versions of the model. As a first algorithm
to try on our model, let's use NIMBLE's default MCMC. Note that all
conjugacy is detected for all nodes except for
\cd{alpha}\footnote{This is because we haven't yet set up NIMBLE to
  detect conjugate relationships involving an exponential
  distribution, but we'll add that one soon.}, on which the default sampler is a random walk Metropolis sampler.


<<mcmcPump, fig.height=3>>=
@ 

Notice the posterior correlation between \cd{alpha} and \cd{beta}.
And a measure of the mixing for each is the 
autocorrelation for each, shown by the \cd{acf} plots. 

\section{Customizing the MCMC}
\label{sec:customizing-mcmc}

Let's add an adaptive
block sampler on \cd{alpha} and \cd{beta} jointly and see if that
improves the mixing. 

<<mcmcPump2, fig.height=3>>=
@ 

We can see that the block sampler has decreased the 
autocorrelation for both \cd{alpha} and \cd{beta}.  Of course these
are just short runs.

Once you learn the MCMC system, you can write your own samplers and
include them.  The entire system is written in nimbleFunctions.

\section{Running MCEM}
\label{sec:running-mcem}

NIMBLE is a system for working with algorithms, not just an MCMC engine. So let's try maximizing the marginal likelihood for \cd{alpha} and \cd{beta} using Monte Carlo Expectation Maximization\footnote{Note that for this model, one could analytically integrate over \cd{theta} and then numerically maximize the resulting marginal likelihood.}. 

<<mcemPump>>=
@ 

Both estimates are within 0.01 of the values reported by George et
al. (1993)\footnote{George, E.I., Makov, U.E. \& Smith,
  A.F.M. 1993. Conjugate likelihood
  distributions. \textit{Scand. J. Statist.} \textbf{20}:147-156.
  Their numbers were accidentally swapped in Table 2.}

\section{Creating your own functions}
\label{sec:creating-your-own}



Now let's see an example of writing our own algorithm and using it on
the model. We'll do something simple: simulating multiple values for a
designated set of nodes and calculating every part of the model that
depends on them.

Here is our \cd{nimbleFunction}:
<<nfPump>>=
@ 

Here are a few things to notice about the \cd{nimbleFunction}
\begin{enumerate}
\item The setup code is written in R.  It creates relevant
information specific to our model for use in the run-time code.  
\item The run-time is written in NIMBLE.  It carries out the
  calculations using the information determined once for each set of
  \cd{model} and \cd{nodes} arguments by the setup
  code. The run-time code is what will be compiled.
\item A \cd{modelValues} object is created to hold multiple sets of
  values for variables
  in the model provided.
\item The NIMBLE code requires type information about the argument
  \cd{n}.  In this case it is a scalar integer.  
\item The for-loop looks just like R, but only sequential integer
  iteration is allowed.
\item The functions \cd{calculate} and \cd{simulate}, which were
  introduced above in R, can be used in NIMBLE.
\item The special function \cd{copy} is used here to record values
  from the model into the modelValues object.  
\item One instance, or ``specialization'', \cd{simNodesTheta1to5}, has
  been made by calling \cd{simNodesMany} with the \cd{pump} model and
  nodes \cd{`theta[1:5]'} as arguments.  These are used as inputs to
  the setup function.  What is returned is an object of a uniquely
  generated reference class with a \cd{run} method (member function)
  that will execute the \cd{run} code.
\end{enumerate}

In fact, \cd{simNodesMany} is very similar to a standard
\cd{nimbleFunction} provided with nimble, \cd{simNodesMV}.

Now let's execute this \cd{nimbleFunction} in R, before compiling it.

<<runPumpSimsR>>=
@ 

In this code we have initialized the values of \cd{alpha}, \cd{beta},
to their MLE, and recorded the \cd{theta} values to use next.  Then we
have requested 10 simulations from
\cd{simNodesTheta1to5}.  Shown are the first two simulation results
for \cd{theta} and the log probabilities of \cd{x}.  Notice that
\cd{theta[6:10]} and the corresponding log probabilities for \cd{x[6:10]} are unchanged because the nodes being simulated are only
\cd{theta[1:5]}.  In R, this function runs slowly.

Finally, let's compile the function and run that version.

<<runPumpSimsC>>=
@ 

Given the same initial values and the same random number generator
seed, we got identical results, but it happened much faster.

\chapter{More Introduction}

Now that we have shown a brief example, we will introduce more about
the concepts and design of NIMBLE.  Subsequent chapters will go into
more detail about working with models and programming in NIMBLE.  

One of the most important concepts behind NIMBLE is to allow a
combination of high-level processing in R and low-level processing in
compiled C++.  For example, when we write a Metropolis-Hastings MCMC
sampler in the NIMBLE language, the inspection of the model structure
related to one node is done in R, and the actual sampler calculations
are done in compiled C++.  The theme of separating one-time high-level
processing and repeated low-level processing will become clearer as we
introduce more about NIMBLE's components.


\section{NIMBLE adopts and extends the BUGS language for specifying models}

We adopted the BUGS language, and we have extended it to make it more
flexible. The BUGS language originally appeared in WinBUGS, then in
OpenBUGS and JAGS.  These systems all provide automatically-generated
MCMC algorithms, but we have adopted only the language for describing
models, not their systems for generating MCMCs. In fact, if you want
to use those or other MCMCs in combination with NIMBLE's other algorithms,
you can\footnote{and will be able to do so more thoroughly in the future}.  We adopted BUGS
because it has been so successful, with over 30,000 registered users
by the time they stopped counting, and
with many papers and books that provide BUGS code as a way to document
their statistical models. To learn the basics of BUGS, we refer you to
the OpenBUGS or JAGS web sites.  For the most part, if you have BUGS code, you can try
NIMBLE.

  NIMBLE takes BUGS code and does several things with it:
  \begin{enumerate}
  \item NIMBLE extracts all the declarations in the BUGS code to
    create a \nm{model definition}.  This includes a directed acyclic graph (DAG)
    representing the model and functions that can 
    inspect the graph and model relationships.  Usually you'll ignore the \nm{model definition}
    and let NIMBLE's default options take you directly to the next step.
  \item From the \nm{model definition}, NIMBLE builds a working model
    in R.  This can be used to manipulate variables and operate the
    model from R.  Operating the model includes calculating,
    simulating, or querying the log probability value of model
    nodes. These basic capabilities, along with the tools to query model
    structure, allow one to write programs that use the model and
    adapt to its structure.
  \item From the working model, NIMBLE generates customized C++ code
    representing the model, compiles the C++, loads it back into R,
    and provides an R object that interfaces to it.  We often call the
    uncompiled model the ``R-model'' and the compiled model the
    ``C-model.''  The C-model can be used identically to the R-model,
    so code written to use one will work with the other.  We use the
    word ``compile'' to refer to
    the entire process of generating C++ code, compiling it and
    loading it into R.
  \end{enumerate}
 
  You'll learn more about specifying and manipulating models in Chapter \ref{cha:building-models}-\ref{cha:using-bugs-models}.
  
  
  \section{The NIMBLE language for writing algorithms}
  \label{sec:nimble-lang-writ}
  
  NIMBLE provides a language, embedded within and similar in style to
  R, for writing algorithms that can operate on BUGS models.  The
  algorithms can use NIMBLE's utilities for inspecting the structure
  of a model, such as determining the dependencies between variables.
  And the algorithms can control the model, changing values of its
  variables and controlling execution of its probability calculations
  or corresponding simulations.  Finally, the algorithms can use
  automatically generated data structures to manage sets of model
  values and probabilities.  In fact, the calculations of the model
  are themselves constructed as functions in the NIMBLE language, as
  are the algorithms provided in NIMBLE's algorithm library.  This
  will make it possible in the future to extend BUGS with new
  distributions and new functions written in NIMBLE.
  
  Like the models themselves, functions in
  the NIMBLE language are turned into C++, which is compiled, loaded,
  and interfaced to R.  

Programming in NIMBLE involves a fundamental distinction between:
\begin{enumerate}
\item the steps for an algorithm that need to happen only
once, at the beginning, such as inspecting the model; and
\item the steps that need to happen each time a function is called, such as MCMC iterations.
\end{enumerate}
Programming in NIMBLE allows, and indeed requires, these steps to be
given separately.  When one writes a \cd{nimbleFunction}, each of
these parts can be provided.  The former, if needed, are given in a \nm{setup
  function}, and they are executed directly in R, allowing any feature
of R to be used.  The latter are in one or more \nm{run-time functions}, and they
are turned into C++.  Run-time code is written in the NIMBLE language,
which you can think of as a carefully controlled, small subset of R
along with some special functions for handling models and NIMBLE's
data structures.

What NIMBLE does with a \cd{nimbleFunction} is similar to what it does
with a BUGS model:
\begin{enumerate}
\item NIMBLE creates a working R version of the \cd{nimbleFunction},
  which you can use with an R-model or a C-model.
\item NIMBLE generates C++ code for the run-time function(s), compiles
  it, and loads it back into R with an interface nearly identical to
  the R version of the \cd{nimbleFunction}.   As for models, we refer
  to the uncompiled and compiled versions as R-nimbleFunctions and
  C-nimbleFunctions, respectively.   In v\ver, the behavior
  of \cd{nimbleFunction}s is usually very similar, but not identical,
  between the two versions.
\end{enumerate}

  You'll learn more about writing algorithms in Chapter \ref{cha:progr-with-models}.
  
\section{The NIMBLE algorithm library}
\label{sec:nimble-algor-libr}

In v\ver, the NIMBLE algorithm library is fairly limited.  It includes:

\begin{enumerate}
\item MCMC with samplers including conjugate, slice, adaptive random
  walk, and adaptive block.  NIMBLE's MCMC system illustrates the
  flexibility of combining R and C++.  An R function inspects the
  model object and creates an MCMC specification object representing
  choices of which kind of sampler to use for each node.  This MCMC
  specification can be modified in R, such as adding new samplers for
  particular nodes, before compiling the algorithm.  Since
  each sampler is written in NIMBLE, you can use its source code or
  write new samplers to insert into the MCMC.  And if you want to
  build an entire MCMC system differently, you could do that too.
\item A \cd{nimbleFunction} that provides a likelihood function for
  arbitrary sets of nodes in any model. This can be useful for simple
  maximum likelihood estimation of non-hierarchical models using R's
  optimization functions.  And it can be useful for other R packages
  that run algorithms on any likelihood function.
\item A \cd{nimbleFunction} that provides ability to simulate,
  calculate, or retrieve the summed log probability (density) of many
 sets of values for
  arbitrary sets of nodes.
\item A basic Monte Carlo Expectation Maximization (MCEM) algorithm.
  MCEM has its issues as an algorithm, such as potentially slow convergence to maximum
  likelihood (i.e. empirical Bayes in this context) estimates, but we chose it as a
  good illustration of how NIMBLE can be used.  Each MCMC step uses
  NIMBLE's MCMC; the objective function for maximization is another
  \cd{nimbleFunction}; and the actual maximization is done through R's
  \cd{optim} function\footnote{In the future we plan to provide direct
    access to R's optimizers from within \cd{nimbleFunction}s}.
\end{enumerate}
  
You'll learn more about the NIMBLE algorithm library in Chapter \ref{cha:algos-provided}.

\chapter{Getting started}
\label{cha:getting-started}

\section{Requirements to run NIMBLE}
\label{sec:requ-run-nimble}

You can run NIMBLE on any of the three common operating systems: Linux, Mac, or Windows. 

The following are required to run NIMBLE.

\begin{enumerate}
\item \href{http://www.cran.r-project.org}{R}, of course.
\item The \href{http://www.cran.r-project.org/web/packages/igraph/index.html}{igraph} R package.
\item A working C++ compiler that R can use on your system.  There are
  standard open-source C++ compilers that the R community has already
  made easy to install.  You don't need to know anything about C++ to
  use NIMBLE.


\end{enumerate}

NIMBLE also uses a couple of C++ libraries that you don't need to install, as they will already be on your system or are provided by NIMBLE.
\begin{enumerate}
\item The \href{http://eigen.tuxfamily.org}{Eigen} C++ library
  for linear algebra.  This comes with NIMBLE, or you can use your own copy.
\item The BLAS and LAPACK numerical libraries.  These come with
  R. 
\end{enumerate}

Most fairly recent versions of these requirements should work. 
% [look into giving more detailed version requirements]

\section{Installation}

Since NIMBLE is an R package, you can install it in the usual way, via
\cd{install.packages()} or related mechanisms.  We have not yet put in
on CRAN, so you'll have to find it at R-nimble.org. 

For most installations, you can ignore low-level details.
However, there are some options that some users may want to utilize.

\subsection{Using your own copy of Eigen}
%\subsection{Finding the Eigen Header Files}
NIMBLE uses the Eigen C++ template library for linear algebra
(\url{http://eigen.tuxfamily.org/index.php?title=Main\_Page)}).  Version 3.2.1
of Eigen is included in the NIMBLE package and that version will be
used unless the package's configuration script finds another version
on the machine.  This works well, and the following is only relevant
if you want to use a different (e.g., newer) version.

The configuration script looks in the standard include directories,
e.g. \cd{/usr/include} and \cd{/usr/local/include} for the header file \cd{Eigen/Dense}.
You can specify a particular location in either of two ways:
\begin{enumerate}
  \item Set the environment variable \cd{EIGEN\_DIR} before installing the R
    package,  e.g., \cd{export EIGEN\_DIR=/usr/include/eigen3} in the bash shell.
  \item Use \verb|R CMD INSTALL --configure-args='--with-eigen=/path/to/eigen' nimble|
      or \\ \cd{install.packages("nimble", configure.args = "--with-eigen=/path/to/eigen")}.
\end{enumerate}  
In these cases, the directory should be the full path to the directory that
contains the Eigen directory, e.g. \cd{/usr/local/include}. It is not the full path to the Eigen
directory itself, i.e., NOT \cd{/usr/local/include/Eigen}.


\subsection{Using libnimble}
NIMBLE generates specialized C++ code for user-specified models and nimbleFunctions.
This code uses some NIMBLE C++ library classes and functions.
By default, on Linux and OS X, the library code is compiled once as a linkable
library - \nm{libnimble}. This single instance of the library is then linked 
with the code for each generated model. Alternatively, one can have
the library code recompiled in each model's own dynamically loadable
library (DLL). This does repeat the same code across models and so occupies
more memory. There may be a marginal speed advantage. 
This is currently what happens on Windows.  One can disable
using \nm{libnimble} via the configuration argument \cd{--enable-lib},
e.g.

\verb|R CMD INSTALL --configure-args='--enable-lib=false' nimble|



\subsection{LAPACK and BLAS} 
NIMBLE also uses BLAS and LAPACK for some of its linear algebra (in particular calculating density values and generating random samples from multivariate distributions). NIMBLE will use the same BLAS and LAPACK installed on your system that R uses. Note that a fast (and where appropriate, threaded) BLAS can greatly increase the speed of linear algebra calculations. See Section A.3.1 of the R Installation and Administration manual for more details on providing a fast BLAS for your R installation. 




\subsection{Problems with Installation}
We have tested the installation on the three commonly used platforms
-- OS X, Linux, Windows 7.  We don't anticipate problems with installation,
but we want to hear about any and help resolve them. 
Please post about installation problems to the nimble-users Google group or 
email \cd{nimble.stats@gmail.com}.


\subsection{RStudio and NIMBLE}
\label{sec:RStudio-problem}

You can use NIMBLE in RStudio, but we strongly recommend that you turn
off the option to display the Global Environment.  Leaving it on can
cause RStudio to freeze, apparently from trying to deal with some of
NIMBLE's data structures.

\section{Installing a C++ compiler for R to use}

In addition to needing a C++ compiler to install the package (from
source), you also need to have a C++ compiler and the utility \nm{make} at
run-time.  This is needed during the R session to compile the C++
code that NIMBLE generates for a user's models and algorithms.

\subsection{OS X}
On OS X, you should install Xcode.  The command-line tools, which are
available as a smaller installation, should be sufficient. This is freely available from the
Mac App Store. See \url{https://developer.apple.com/xcode/downloads/}
and \url{https://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12}

\subsection{Linux}
On Linux, you can install the GNU compiler suite (\nm{gcc}/\nm{g++}). 
You can use the package manager to install pre-built binaries.
On Ubuntu, the following command will install or update \nm{make}, \nm{gcc} and \nm{libc}.
<<chunk1, engine='bash', eval=FALSE>>=
sudo apt-get install build-essential
@ 



\subsection{Windows}
On Windows, you should download and install \file{Rtools.exe} available from
\url{http://cran.r-project.org/bin/windows/Rtools/}.  Select the appropriate
executable corresponding to your version of R.  (We strongly recommend
using the most recent version of R, currently 3.1.0, and hence
\file{Rtools31.exe}).  This installer leads you through several
``pages''. You can accept all of the defaults. It is essential the
checkbox for the ``R 2.15+ toolchain'' (page 4) is enabled in order to
have \nm{gcc}/\nm{g++}, \nm{make}, etc. installed.  Also, we recommend that you check
the PATH checkbox (page 5).  This will ensure that R can locate these
commands.



\section{Customizing Compilation of the NIMBLE-generated Code}

For each model or nimbleFunction, the NIMBLE package generates and compiles
C++ code. This uses classes and routines available through the NIMBLE run-time
library and also the Eigen library. The compilation mechanism uses R's
SHLIB functionality and so the regular R configuration in
\verb|${R_HOME}/etc${R_ARCH}/Makeconf|. NIMBLE places a \file{Makevars}
file in the directory in which the code is generated and \verb|R CMD SHLIB| uses this file.

In all but specialized cases, the general compilation mechanism will
suffice. However, one can customize this.  One can specify the
location of an alternative \file{Makevars} (or \file{Makevars.win})
file to use.  That should define the variables \cd{PKG\_CPPFLAGS} and
\cd{PKG\_LIBS}.  These should contain, respectively, the pre-processor flag
to locate the NIMBLE include directory, and the necessary
libraries to link against (and their location as necessary),
e.g., \nm{Rlapack} and \nm{Rblas} on Windows, and \nm{libnimble}.

Use of this file allows users to specify additional compilation and
linking flags.  See the Writing R Extensions manual for more details
of how this can be used and what it can contain.



\chapter{Building models}
\label{cha:building-models}

%% This was the old first model example.  It may be superceded by the
%% new "brief example" chapter 2.

%% \subsection{Writing your first NIMBLE model}
%% \label{sec:first-model}

%% Here we give a toy example of specifying and manipulating a BUGS model. 

%% Let's jump in by looking at a simple example: a function that sets a
%% node to an input value, calculates the log probability components\footnote{Of course for continuous distributions these are density values not probabilities, but we'll use ``log probability'' loosely.} 
%% related to that value, and returns their sum.  The NIMBLE code and
%% usage looks like this.


%% <<cache=TRUE>>=
%% model1 <- BUGScode({
%%     a ~ dnorm(mean = 0, tau = 0.01)
%%     y ~ dnorm(mean = a, sd = 2)
%% })

%% Rmodel1 <- BUGSmodel(model1, returnModel = TRUE)
%% @ 

%% \cd{Rmodel1} is the R-version of the model, and it can be used right away,
%% like this:
%% <<>>=
%% Rmodel1$a <- 3
%% simulate(Rmodel1, 'y')
%% Rmodel1$y
%% calculate(Rmodel1, c('a', 'y'))
%% dnorm(3, 0, 1/sqrt(0.01), log = TRUE) + dnorm(Rmodel1$y, 3, 2, log = TRUE)
%% @ 

%% In the above example, first we set the value of $a$ to 3.  Then we
%% simulate a value for $y$.  Then we calculate the log probabilities of
%% $a$ and $y$.  Then we show that they are correct.  Note that one of
%% the dnorms uses a precision parameter ("tau") while the other uses a
%% standard deviation. \footnote{The NIMBLE dialect of BUGS allows for a variety of common parameterizations.}

%% Rmodel1 also contains an \nm{igraph} object of the graph, which can be
%% plotted using the functionality of the \nm{igraph} package:
%% <<fig.width=5, fig.height=5>>=
%% plot(Rmodel1$graph)
%% @ 

NIMBLE aims to be compatible with the original BUGS language and also
the version used by the popular JAGS package, as well as to extend the
BUGS language.  However, at this point, there are some BUGS
features not supported by NIMBLE, and there are some extensions that
are planned but not implemented.

Here is an overview of the status of BUGS features, followed by more
detailed explanations of each topic.

\section{NIMBLE support for  features of BUGS}
\label{sec:supp-feat-bugs}

\subsection{Supported features of BUGS}

\begin{enumerate}
\item Stochastic and deterministic\footnote{NIMBLE calls non-stochastic nodes ``deterministic'', whereas BUGS calls them ``logical''. NIMBLE uses ``logical'' in the way R does, to refer to boolean (TRUE/FALSE) variables.} node declarations.
\item Most univariate and multivariate distributions
\item Link functions
\item Most mathematical functions
\item ``for'' loops for iterative declarations.
\item Arrays of nodes up to 3 dimensions.
\end{enumerate}


\subsection{Not-yet-supported features of BUGS}
\label{sec:not-yet-supported}

Eventually, we plan to make NIMBLE fully compatible with BUGS
and JAGS.  In this first release, the following are
\textit{not} supported.

\begin{enumerate}
\item Stochastic indices
\item The \cd{I()} notation
\item Aspects of the JAGS dialect of BUGS, such as the \cd{T()}
  notation and \cd{dinterval()}.
\item The appearance of the same node on the left-hand side of both a
  \cd{<-} and a \cd{$\sim$} declaration, allowing data assignment for
  the value of a stochastic node.
\item Like BUGS, NIMBLE generally determines the dimensionality and
  sizes of variables from the BUGS code.  However, when a variable
  appears with blank indices,
  such as in \cd{x.sum <- sum(x[])}, NIMBLE currently requires that the
  dimensions of x be provided.
\end{enumerate}


\subsection{Extensions to BUGS}
\label{sec:extensions-bugs}

NIMBLE also extends the BUGS language in the following ways:

\begin{enumerate}
\item Distribution parameters can be expressions, as in JAGS but not
  in WinBUGS\footnote{e.g., \cd{y ~ dnorm(5 + mu, 3 *
      exp(tau))}}.  Caveat: parameters to \emph{multivariate}
  distributions (\emph{e.g.,} \cd{dmnorm()}) may not be expressions, but
  must be [appropriately indexed] model nodes.
\item Named parameters for distributions, similar to named parameters in R's distribution functions.
\item Multiple parameterizations for distributions, similar to those
  in R.
\item More flexible indexing of vector nodes within larger variables,
  such as placing a multivariate normal vector arbitrarily within a
  higher-dimensional object, not just in the last index.
\end{enumerate}

\subsubsection{Extension for handling ``data''}
\label{sec:diff-handl-data}

In BUGS, when you define a model, you provide \textit{the} data for
the model.  You can use NIMBLE that way too, but NIMBLE provides more
flexibility.  Consider, for example, a case where you want to use the
same model for many data sets.  Or, consider a case where you want to
use the model to simulate many data sets from known parameters.  In
such cases, the model needs to know what nodes have
``data''\footnote{because algorithms will want to query the model
  about its nodes}, but the values of the data nodes can be modified.

To accommodate such flexibility, NIMBLE separates the concept of data
into two concepts:
\begin{enumerate}
\item ``Constants'', which are provided when the model is defined and can
  never be changed thereafter.  For example, a vector of known index
  values, such as for block indices, helps define the model graph
  itself and must be provided when the model is defined.  NIMBLE
  ``constants'' are like BUGS ``data'', because they cannot be changed.
\item ``Data'', which are provided when an instance of a model is
  created from the model definition.  When data are provided, their
  values are used and their nodes are flagged as data so that
  algorithms can use that information.
\end{enumerate}

\subsubsection{Future extensions to BUGS}
\label{sec:future-extens-bugs}

We also plan to extend the BUGS language to support:
\begin{enumerate}
\item Ability to provide new functions and new distributions written NIMBLE.
\item If-then-else syntax for one-time evaluation when the model is
  compiled, so that the same model code can generate different models
  when different conditions are met.
\item Single-line declaration of common motifs such as GLMs, GLMMs, and time-series models.
\end{enumerate}


\section{Creating models}

Here we describe in detail two ways to provide a BUGS model for use by
NIMBLE.  The first, \cd{nimbleModel}, is the primary way to do it and
was illustrated in Chapter \ref{cha:intro} .
The second, \cd{readBUGSmodel} provides compatibility with BUGS file
formats for models, variables, data, and initial values for MCMC.  

\subsection{Using \cd{nimbleModel()} to specify a model}

There are five arguments to \cd{nimbleModel} that provide information
about the model, of which \cd{code} is
the only required one.  Understanding these arguments involves some
basic concepts about NIMBLE and ways it differs from BUGS and JAGS, so
we explain them here. The R help page (\cd{?nimbleModel}) provides a
reference for this information.

\begin{description}
\item[code] This is R code for the BUGS model.  With just a few
  exceptions such as \cd{T()} and \cd{I()} notation, BUGS code is
  syntactically compatible with R, so it can be held in an R object.
  There are three ways to make such an object, by using
  \cd{nimbleCode()}, the synonym \cd{BUGScode()}, or simply the R
  function \cd{quote()}.

\item[constants] This is a named list of values that cannot be modified after
  creating the model definition.  They may include constants such as
  \begin{enumerate}
  \item \cd{N} in the pump example, which is required for processing
    the BUGS code since it appears in \cd{for(i in 1:N)}.
  \item vectors of indices, such as when the model has nodes like
    \cd{y[i] $\sim$ dnorm(mu[blockID[i] ], sd)}, where \cd{blockID} is a
    vector of experimental block IDs that indicate which \cd{mu} is needed
    for each \cd{y}.  Since vectors of indices are used to define the
    model graph, they cannot be changed after model definition
  \item actual data, if they will never be changed.  Note that data
    may alternatively be provided via the \cd{data} argument or the
    \cd{setData} member function, in which case the model knows those
    nodes represent data, but their values may be changed.  This
    allows the same model to be used to analyze or to simulate
    multiple data sets. 
  \end{enumerate}
\item[dimensions] This is a named list of vectors of the sizes of
  variables that appear in the model with unfilled indices such as
  \cd{x[,]}.  For the most part, NIMBLE determines the sizes of model
  variables automatically, but in cases with blank index fields,
  dimension information is required. As described in the section below
  about indexing, NIMBLE currently requires square brackets with blank
  indices (or complete indicies such as \cd{1:N}, of course) when the full extent of a variable is needed.  The dimension
  argument for \cd{x[,]} would be e.g. \cd{list(x = c(10, 8))} if \cd{x} is a 10-by-8
  matrix.  Dimension information can alternatively be taken from
  \cd{constants} or \cd{data} if these are provided.  \footnote{We
    have also seen cases where the dimension information inferred from
    the BUGS code does not match the data matrix because the model
    only applies to a subset of the data matrix.  In a case like that,
    either \cd{dimensions} must be provided to fit the entire data
    matrix or only the appropriate subset of the data matrix must be
    used in the model.}
\item[data] This is a named list of values to be used as data, with
  \cd{NA}s to indicate missing data.
\item[inits] This is a named list of initial values for the model.
  These are neither data nor constants, but rather values with which to
  initialize the model. 
\end{description}
          
\subsection{More about specifying data nodes and values}
\label{sec:more-about-spec}


\subsubsection{NIMBLE distinguishes between constants and data}

As described in section \ref{sec:diff-handl-data}, NIMBLE considers
\nm{constants} to be values that will never change and \nm{data} to be
information about the role a node plays in the model.  Nodes marked as
\nm{data} will by default be protected from any functions that would
simulate over their values, but it is possible to do so or to change
their values by direct assignment.  Attempting to change the values of
\nm{constants} after building a model can lead to errors. 

\subsubsection{Providing data via setData}

Whereas the \nm{constants} are a property of the \nm{model
  definition} -- since they may help determine the model structure
itself -- \nm{data} nodes can be different in different copies of the
model generated from the same \nm{model definition}.  For this reason,
\nm{data} is not required to be provided when the model code is
processed.  It can be provided later via the model member function
\cd{setData}. e.g.,
\cd{pump\$setData(pumpData)}, where \cd{pumpData} is a named list of
data values.

\cd{setData} does two things: it sets the values of the data nodes,
and it flags those nodes as containing data so that NIMBLE's
\cd{simulate()} functions do not overwrite data values. Values of data
variables can be replaced normally, and the indication of which nodes
should be treated as data can be reset by using the \cd{resetData}
method, e.g. \cd{pump\$resetData()}.

Since values passed into the \cd{constants} argument of
\cd{nimbleModel()} can never be modified, they are also marked as data
in a model so that algorithms will be prevented from trying to
simulate into them.

\subsubsection{Missing data values}

When a variable that functions as data in a model has missing values, one should set the nodes whose values are missing to be \cd{NA},  either
through the \cd{data} argument when creating a model or via
\cd{setData}. The result will be that nodes with non-\cd{NA} values will be flagged as data nodes, while nodes with \cd{NA} values will not.  Note that a node following a multivariate distribution must be either entirely observed or entirely missing.

%This example seems too extensive for this minor point, but I guess it
%helps. -Perry
Here's an example of running an MCMC on the \nm{pump} model, with two of the observations taken to be missing. Our default MCMC specification will treat the missing values as unknowns to be sampled, as can be seen in the MCMC output here.

<<pump-missing>>=
pumpMiss <- pump$newModel()
pumpMiss$resetData()
pumpDataNew <- pumpData
pumpDataNew$x[c(1, 3)] <- NA
pumpMiss$setData(pumpDataNew)

pumpMissSpec <- configureMCMC(pumpMiss)
pumpMissSpec$addMonitors(c('x', 'alpha', 'beta', 'theta'))

pumpMissMCMC <- buildMCMC(pumpMissSpec)
Cobj <- compileNimble(pumpMiss, pumpMissMCMC)

niter <- 1000
set.seed(0)
Cobj$pumpMissMCMC$run(niter)
samples <- as.matrix(Cobj$pumpMissMCMC$mvSamples)

samples[1:5, 13:17]

@ 


\subsection{Using \cd{readBUGSmodel()} to specify a model}

\cd{readBUGSmodel()} can read in the model, data/constant
values and initial values in formats mostly compatible with the \cd{bugs()} and
\cd{jags()} functions in the \nm{R2WinBUGS} and \nm{R2jags} packages.
It can also take information directly
from R objects, somewhat more flexibly than \cd{nimbleModel()}. 
After processing the file inputs, it calls \cd{nimbleModel()}.

\cd{readBUGSmodel()} can take the following arguments:

\begin{description}
\item[model] is either a file name, an R code object such as can be
  passed in the \cd{code} argument of \cd{nimbleModel()}, or a R
  function whose body contains the model code. 
\item[data] is either a file name or a named list specifying constants
  and data together, the way they would be provided for BUGS or JAGS.
  \cd{readBUGSmodel()} treats values that appear on the left-hand side
  of BUGS declarations as data and other values as constants, so you
  do not need to call the \cd{setData} method.
\item[inits] is either a file name or a named list of initial values.  
\end{description}

For both \cd{data} and \cd{inits}, if a file is specified, the file
should contain R code that creates objects analogous to what would
populate the list if a list were provided instead.  Please see the
JAGS manual examples or the \file{classic\_bugs} directory in the
NIMBLE package for example syntax. NIMBLE does not handle formatting
such as in some of the original BUGS examples in which data was
indicated with syntax such as \cd{data x in `x.txt'}.  Only a single
set of initial values can specified in creating a model; multiple sets of initial values will (eventually) be handled in NIMBLE's MCMC implementation. 

\subsubsection{Example using \cd{readBUGSmodel}}
\label{sec:example-using-cdre}

Let's create a model for the \nm{pump} example from BUGS.
<<readBUGSmodel>>=
pumpDir <- system.file('classic-bugs', 'vol1', 'pump', package = 'nimble')
pumpModel <- readBUGSmodel('pump.bug', data = 'pump-data.R', 
                           inits = 'pump-init.R', dir = pumpDir)
                           
@ 

Note that \cd{readBUGSmodel()} allows one to include \cd{var} and \cd{data} blocks in the model file as in some of the BUGS examples (such as \cd{inhaler}). The \cd{data} block pre-computes constant and data values. 
% PdV - at some point I think there was discussion of code that would appear in a 'data' block being put in the model code directly, but I think this could lead to variable on the LHS twice with <- and ~, so I think I'm not understanding what we want to allow in code defining a model
% I have no recollection of that idea.  Doesn't sound safe. -Perry
NIMBLE by and large does not need the information given in a \cd{var}
block but occasionally this is used to determine dimensionality, such
as in the case of syntax like \cd{xbar <- mean(x[])} where \cd{x} is a variable that appears only on the right-hand side of BUGS expressions.   

\subsection{A note on introduced nodes}
\label{sec:introduced-nodes}

In some cases, NIMBLE introduces new nodes into the model that were
not specified in the BUGS code for the model, such as the
\cd{lifted\_d1\_over\_beta} node in the introductory example.  For
this reason, it is important that programs written to adapt to
different model structures use NIMBLE's systems for querying the model
graph.  For example, a call to \cd{pump\$getDependencies("beta")} will
correctly include \cd{lifted\_d1\_over\_beta}  in the results.  If one
skips this step and assumes the nodes are only those that appear in
the BUGS code, one may not get correct results.

It can be helpful to know the situations in which lifted nodes are
generated.  These include:

\begin{itemize}
\item When distribution parameters are expressions, NIMBLE
  creates a new deterministic node that contains the expression for a
  given parameter. The node is then a direct descendant of the new
  deterministic node.  This is an optional feature, but it is
  currently enabled in all cases.
\item As discussed in \ref{subsec:BUGS-link} the use of link functions causes new nodes to be introduced.
\item Use of alternative parameterizations of distributions. For
  example when a user provides the precision of a normal distribution
  as \cd{tau}, NIMBLE creates a new node \cd{sd <- 1/sqrt(tau)} and
  uses \cd{sd} as a parameter in the normal distribution.  If many
  nodes use the same \cd{tau}, only one new \cd{sd} node will be
  created, so the computation \cd{1/sqrt(tau)} will not be repeated
  redundantly.  More about NIMBLE's parameterizations is described below.
  
\end{itemize}


\section{More details on NIMBLE support of BUGS features}
\label{sec:more-details-nimble}

\subsection{Distributions}
\label{subsec:distributions}

NIMBLE supports most of the distributions allowed in BUGS and JAGS. Table \ref{table:distributions} lists the distributions currently supported.

To understand how NIMBLE handles alternative parameterizations, it is
useful to distinguish three cases, using the \cd{gamma} distribution
as an example:
\begin{enumerate}
\item A \nm{canonical} parameterization is used directly for
  computations.  Usually this is the parameterization in the
  \cd{Rmath} header of R's C implementation of distributions.  For
  \cd{gamma}, this is (shape, scale).  
\item The \nm{BUGS} parameterization is the one defined in the
  original BUGS language.  For \cd{gamma}, this is (shape, rate).
\item An \nm{alternative} parameterization is one that must be converted
  into the \nm{canonical} parameterization.  For example, NIMBLE
  provides a (mean, sd) parameterization and creates nodes to
  calculate (shape, scale) from (mean, sd).  In the case
of \cd{gamma}, the \nm{BUGS} parameterization is also an \nm{alternative} parameterization.

\end{enumerate}

Since NIMBLE aims to provide compatibility with existing BUGS and JAGS
code, the order of parameters places the \nm{BUGS} parameterization
first.  For example, the NIMBLE definition of a \cd{gamma}, in R
format, is \cd{dgamma( shape, rate, scale, mean, sd)}.  Like R, if
parameter names are not given, they are taken in order, so that (shape,
rate) is the default. This happens to  match R's order of parameters,
but it need not.  If names are given, they can be given in any
order.  NIMBLE knows that rate is an alternative to scale and that
(mean, sd) are an alternative to (shape, scale or rate). 

The file \file{distsDefs\_table.R} in the R directory of the source
package is the definitive source for the NIMBLE's distributions and parameterizations.

We plan to, but do not currently, handle the following distributions: double exponential (Laplace), beta-binomial, Dirichlet-multinomial, F, Pareto, inverse Wishart, and various forms of multivariate t. 

We will shortly add the distribution aliases allowed in JAGS: \cd{dbinom}, \cd{dnbinom}, \cd{dweibull}, \cd{ddirich}.

% Note that for certain multivariate distributions, such as the multivariate normal and the Wishart, we parameterize the distributions internally in terms of Cholesky decompositions, and which matrix is decomposed depends on which matrix is provided by the user. For example if the user provides a variance matrix, we parameterize in terms of the Cholesky of the variance and if the precision is provided we parameterize in terms of the Cholesky of the precision. This helps to avoid doing unneeded matrix inverses in computing with a model.

% [F is easy to add as it has R functions]

\input{densityTable.tex}

% CJP still not satisfied with this table as we don't show how some of the parameterizations relate to the densities in the previous table - e.g. we don't say how weibuill(shape,scale) relates to shape,lambda in previous table

\subsection{List of parameterizations}


NIMBLE extends BUGS by allowing different standard parameterizations
of distributions.  These are listed in Table \ref{table:distributions-alternates}.

\input{parameterizationTable.tex}

\subsection{List of BUGS language functions}
\label{subsec:BUGS-lang-fxns}

NIMBLE provides a wide variety of operators and functions for use in
defining models (Tables
\ref{table:functions}-\ref{table:functions-matrix}). Note that by
virtue of how we set up models using the NIMBLE language, these are
the same operators and functions that one can use in a NIMBLE
function, as discussed further in Chapter \ref{cha:progr-with-models}.

For the most part NIMBLE supports the functions used in BUGS and JAGS,
with exceptions indicated in the table.  Additional functions provided
by NIMBLE are also listed.  For distribution functions, currently
``r'' and ``d'' functions are provided for each distribution, and when
called from \cd{nimbleFunctions} only the BUGS parameterization is
available in v\ver, and in fact sometimes that is provided
differently.  See \ref{sec:nimble-dist-funs}.  Currently ``r'' functions only return one random
draw at a time, and the first argument must always be 1.  For
multivariate distribution functions the \cd{prec\_param} or
\cd{scale\_param} argument must be provided, indicating when a
covariance or precision matrix has been given.  In a future release we
will provide a variety of distribution functions, including density,
cumulative distribution and quantile functions, using the same syntax
as \cd{dnorm}, \cd{pnorm}, \cd{qnorm}.  We will also extend the
alternative parameterizations with named parameters to
\cd{nimbleFunctions}.


\input{functionTable.tex}
\input{functionTableMatrix.tex}

% note to us: not worknig now as Eigen expects 5 input arguments (e.g. to dnorm) not what the user would expect

% [NOTE: JAGS source package has the Tex files for Martyn's manual, so we can copy the table formatting - s doc/manual/jags\_user\_manual.tex]

\subsection{List of link functions}
\label{subsec:BUGS-link}

NIMBLE allows the link functions listed in Table \ref{table:links}.

\begin{table}[!h]
\begin{center}
\begin{tabular}{llll}
\hline
Link function         & Description & Range & Inverse \\
\hline
\verb+cloglog(y) <- x+ & Complementary log log & $0 < y < 1$ & \verb+y <- icloglog(x)+ \\
\verb+log(y) <- x+    & Log           & $0 < y$ &  \verb+y <- exp(x)+ \\
\verb+logit(y) <- x+  & Logit         & $0 < y < 1$ &  \verb+y <- expit(x)+ \\
\verb+probit(y) <- x+ & Probit        & $0 < y < 1$ &  \verb+y <- iprobit(x)+\\
\hline
\end{tabular}
\caption{Link functions \label{table:links}}
\end{center}
\end{table}
      
Link functions are specified as functions applied to a variable on the
left hand side of a BUGS expression. To handle link functions, NIMBLE
does some processing that inserts an additional node into the model.
For example, the declaration \cd{logit(p[i]) $\sim$ dnorm(mu[i],1)}, is equivalent
to the follow two declarations: 
\begin{itemize}
\item \cd{logit\_p[i] $\sim$ dnorm(mu[i], 1)},
\item \cd{p[i] <- expit(logit\_p[i])}
\end{itemize}
where \cd{expit} is the inverse of \cd{logit}.  When the BUGS expression defines a deterministic node, such as \cd{logit(p) <- b0 + b1*x}, the same operations are performed except that \cd{logit\_p} is a deterministic node. 

\subsection{Indexing}
\label{sec:indexing} 

NIMBLE allows flexible indexing that is compatible with BUGS and JAGS.

In particular NIMBLE allows
\begin{itemize}
\item \verb|x[i]|
\item \verb|x[i:j]|
\item \verb|x[i:j,k:l]| and indexing of higher dimensional arrays
\item \verb|x[i:j, ]| 
\item \verb|x[3*i+7]|
\item \verb|x[(3*i):(5*i+1)]|
\end{itemize}
 
When calling functions such as \cd{mean} and \cd{sum} on a vector
variable, the square brackets are required but can have blank indices,
e.g. \cd{xbar <- mean(x[])} if \cd{x} is a vector and \cd{xbar <-
  mean(x[,])} if \cd{x} is a matrix \footnote{This is a case where the
  dimension of x must be provided when defining the model.}. 

NIMBLE does not allow multivariate nodes to be indicated without
square brackets, which is an incompatibility with JAGS.  Therefore a
statement like \cd{xbar <- mean(x)} in JAGS must be converted to
\cd{xbar <- mean(x[])} for NIMBLE.

Here's an example of indexing in the context of multivariate nodes,
showing two ways to do the indexing.  The first provides indices, so
no \cd{dimensions} argument is needed, while the second omits the
indices and provides a \cd{dimensions} argument instead.

<<multivar-index>>=
code <- nimbleCode({
  y[1:K] ~ dmulti(p[1:K], n)
  p[1:K] ~ ddirch(alpha[1:K])
  log(alpha[1:K]) ~ dmnorm(alpha0[1:K], R[1:K, 1:K])
})

K <- 5
model <- nimbleModel(code, constants = list(n = 3, K = K,
                          alpha0 = rep(0, K), R = diag(K)))

codeAlt <- nimbleCode({
  y[] ~ dmulti(p[], n)
  p[] ~ ddirch(alpha[])
  log(alpha[]) ~ dmnorm(alpha0[], R[ , ])
})

model <- nimbleModel(codeAlt, constants = list(n = 3, K = K,
                          alpha0 = rep(0, K), R = diag(K)),
                  dimensions = list(y = K, p = K, alpha = K))
                  
                                           
@ 


A limitation to NIMBLE at present is that it allows only contiguous
indexed blocks.  In particular, it does not allow:
\begin{itemize}
\item Non-contiguous sub-indexing such as \cd{c(1, 3, 4, 8)} or \cd{seq(2,
  10, by = 2)}
\item Logical sub-indexing such as \cd{c(TRUE, FALSE, TRUE)} 
\end{itemize}


\subsection{Censoring and truncation}

\cd{T()} and \cd{dinterval()} provide for truncation and censoring,
respectively, in the JAGS dialect of BUGS. These will be enabled in a
release of NIMBLE in the near term.  JAGS provides \cd{I()} for
backwards compatibility with BUGS, only for the case that the node to
which \cd{I()} is applied has fixed parameters and we will enable this
usage in NIMBLE as well.  For more discussion of truncation vs. censoring, please see the JAGS manual. 

\section{Compiling models}
\label{sec:compiling-models}

A compiled model inherits all the information from
the uncompiled model and is initialized from its values. However,  once the C++ version of the model is
created, these are two distinct models and changing values in one
model does not affect the other model. However, they are considered to
have a one-to-one relationship:  You can make a second copy of the uncompiled
model and from that a second compiled model, but you cannot make two
compiled models from the same uncompiled model.

Continuing the example from above, compilation is done as follows.

<<compile-model>>=
CpumpModel <- compileNimble(pumpModel)
@ 

The \cd{compileNimble} function will be described in more detail
later.  Additional arguments can specific what directory to use for
C++ code and what other NIMBLE objects are part of the same project.

Once one has the C-model in hand one can manipulate it in exactly the
same way one manipulates the R-model.  Both versions of the model are
represented in R as Reference Class objects inheriting from the same
base class.

\chapter{Using NIMBLE models from R}
\label{cha:using-bugs-models}

\section{Some basic concepts and terminology}
\label{sec:some-basic-concepts}

Before going further, we need some basic concepts and terminology to
be able to speak about NIMBLE clearly.  
% First, we must refer users unfamiliar with BUGS to the BUGS manual (or maybe we should provide a short summary?).  
% don't think this line above is needed anymore - CJP

Say we have the following BUGS code

<<echo=FALSE>>=
read_chunk(file.path('chunks', 'usingBugsModels_chunks.R'))
@ 

<<usingModelsExample>>=
@ 

In NIMBLE terminology:
\begin{itemize}
\item The \textit{variables} of this model are \nm{a} and \nm{y}.
\item The \textit{nodes} of this model are \cd{a}, \cd{y[1]}, ...,  \cd{y[5]}, and \cd{z[1,1]}, ..., \cd{z[5, 3]}.
\item the \textit{node functions} of this model are \verb|a ~ dnorm(0, 0.001)|, 
  \verb|y[i] ~ dnorm(a, 0.1)| and \verb|z[i,j] ~ dnorm(y[i], sd = 0.1)|. Sometimes the
  distinction between nodes and node functions is important, but
  when it is not important
  we may refer to both simply as \textit{nodes}.
\end{itemize}

\section{Accessing variables}
\label{sec:accessing-variables}

Model variables can be accessed and set just as in R using \cd{\$} and
\cd{[[ ]]}.  For example

<<usingModelVars>>=
@ 

\subsection{Accessing log probabilities via logProb variables}
\label{sec:access-log-prob}

For each variable that contains at least one stochastic scalar node, NIMBLE generates a model variable with the
prefix  ``logProb\_'' that usually matches the variable's size.  For example

<<usingModelLogProbs>>=
@ 

Creation of \cd{logProb} variables for stochastic multivariate nodes
is trickier, because they can represent an arbitrary block of a larger
variable.  In general NIMBLE records the logProb values using
the lowest possible indices.  For example, if \cd{x[5:10, 15:20]}
follows a Wishart distribution, its log probability (density) value
will be stored in \cd{logProb\_x[5, 15]}.  When possible, NIMBLE will
reduce the dimensions of the corresponding logProb variable.  For
example, in

<<eval = FALSE>>=
for(i in 1:10) x[i,] ~ dmnorm(mu[], prec[,])
@ 

\cd{x} may be 10$\times$20 (dimensions must be provided), but \cd{logProb\_x}
will be 10$\times$1.  For the most part you do not need to worry about
how NIMBLE is storing the log probability values, because you can
always get them using \cd{getLogProb}.  

\section{Accessing nodes}
\label{sec:accessing-nodes}

While nodes that are part of a variable can be accessed as above, each
node also has its own name that be used to access it directly.  For
example, \cd{y[2]} has the name ``y[2]'' and can be accessed by that
name as follows:

<<usingNodeNames>>=
@ 

Notice that node names can include index blocks, such as \cd{model[[`z[2:4, 1:2]']]}, and these are not strictly required to correspond to actual nodes.  Such blocks can be subsequently sub-indexed in the regular R manner.

\subsection{How nodes are named}
\label{sec:how-nodes-are}

Every node has a name that is a character string including its
indices, with a space after every comma.  For example, \cd{X[1, 2, 3]}
has the name ``X[1, 2, 3]''.  Nodes following multivariate
distributions have names that include their index blocks.  For
example, a BUGS declaration creating a multivariate node for \cd{X[6:10, 3]} has the name ``X[6:10, 3]''.

The definitive source for node names in a model is
\cd{getNodeNames()}, described below.  For example

<<multivariateDecExample>>=
@ 

You can see one lifted node for the Cholesky decomposition of
\cd{cov}, and the two multivariate normal nodes.

In the event you need to ensure that a name is formatted correctly,
you can use R's \cd{parse()} and \cd{deparse()} functions.  For
example, to get the spaces correctly inserted into ``X[1,1:5]'':

<<>>=
deparse(parse(text = "X[1,1:5]", keep.source = FALSE)[[1]])
@ 


The \cd{keep.source = FALSE} makes \cd{parse()} more efficient.

\subsection{Why use node names?}
\label{sec:why-use-node}

Syntax like \cd{pump[["x[2, 3]"]]} may seem strange at first.  To see
its utility, consider the example of writing the nimbleFunction given in
\ref{sec:creating-your-own}.  By giving every scalar node a name, even
if it is part of a multivariate variable, one can write functions in R
or NIMBLE that access any single node by a name.  This is particularly
useful for NIMBLE, which resolves how to access a particular node
during the compilation process.

\section{\cd{calculate()}, \cd{simulate()}, and \cd{getLogProb()}}
\label{sec:cdcalc-cdsim-cdgetl}

The three basic ways to operate a model are to calculate nodes,
simulate into nodes, or get the log probabilities (or probability
densities) that have already been calculated.  In more detail:

\begin{description}
\item[calculate] For a stochastic node,
\cd{calculate} determines the log probability value, stores it, and
returns it.  For a deterministic node, \cd{calculate} executes the
deterministic calculation and returns 0.
\item[simulate] For a stochastic node, \cd{simulate} generates a
  random draw.  For deterministic nodes,
\cd{simulate} is equivalent to \cd{calculate} without returning
0. \cd{simulate} always returns \cd{NULL} (or \cd{void} in C++).
\item[getLogProb]   \cd{getLogProb} simply
returns the most recently calculated log probability value, or 0 for a
deterministic node.
\end{description}

There are two ways to access \cd{calculate}, \cd{simulate}, and
\cd{getLogProb}.  The primary way is via the functions with those
names, which can use arbitrary collections of nodes.  In that case,
\cd{calculate} and \cd{getLogProb} return the sum of the log
probabilities from each node.  The other way is to directly access the corresponding function
for each node in a model.  Normally you'll use the first way, but
we'll show you both.

\subsection{For arbitrary collections of nodes}
\label{sec:arbitr-coll-nodes}

<<calcSimGLPdemos>>=
@ 

Notice that 
\begin{enumerate}
\item inputs like \cd{`y[1:3]'} are automatically expanded into
  \cd{c(`y[1]', `y[2]', `y[3]')}.  In fact, simply \cd{`y'} will be
  expanded into all nodes within \cd{y}.
\item an abitrary number of nodes can be provided as a character
vector
\item simulations will be done in the order provided, so in practice
  the nodes will often be obtained by functions like
  \cd{getDependencies} described below.  These return nodes in
  topologically sorted order, which means no node comes before something
  it depends on.
\item The data nodes \cd{z} were not simulated over until
  \cd{includeData = TRUE} was used.
\item In v\ver\ it is not allowed to leave an index blank. For example
  \cd{simulate(model, `z[1,]')} is an error.
\end{enumerate}

Use of \cd{calculate} and \cd{getLogProb} is simliar to \cd{simulate},
except that they return the sum of the log probabilities (densities)
of the nodes requested, and they have not \cd{includeData} argument.

\subsection{Direct access to each node's functions}
\label{sec:direct-access-each}

Access to the underlying \cd{calculate}, \cd{simulate}, and
\cd{getLogProb} functions built by NIMBLE can be had as follows:

<<calcSimGLPdirect>>=
@ 

\section{Querying model parameters}
\label{sec:query-model-param}

Models also have a system for querying the value of any distribution parameter,
including parameters from alternative parameterizations.  In v\ver,
this is an advanced topic to be described later.  

\section{Querying model structure}
\label{sec:query-model-struct}

NIMBLE provides functionality by which one can determine the structure
of a model. This can be used directly from R or in the setup code of
an algorithm as discussed in Chapter \ref{cha:progr-with-models}.  
These functions also work with the compiled version of a model.

Here we demonstrate this functionality using the \nm{pump} example because it has a few more interesting components than the example above. 

<<reinitPumpModel,echo=FALSE>>=
@ 

\subsection{\cd{getNodeNames()} and \cd{getVarNames()}}
\label{sec:cdgetn-cdgetv}


First we'll see how to determine the nodes and variables in a model.

<<getNodeNames>>=
@ 

Note that some of the nodes may be ``lifted'' nodes introduced by NIMBLE as discussed in Section \ref{sec:introduced-nodes}.


\subsection{\cd{getDependencies()}}
\label{sec:cdgetdependencies}

Next we'll see how to determine the node dependencies in a
model. There are a variety of arguments that allow one to specify
whether to include the node itself, whether to include deterministic
or stochastic or data dependents, etc. By default \cd{getDependencies}
returns descendants up to the next stochastic node on all edges of the
graph.  This is what would be needed to calculate a Metropolis-Hastings acceptance probability in MCMC, for example.

<<getDependencies>>=
@ 


\subsection{\cd{isData()}}
\label{sec:cdisdata}

Finally, you can query whether a node is a data node using the \cd{isData} method applied to one or more nodes:
<<isData>>=
pump$isData('x[1]')
pump$isData(c('x[1]', 'x[2]', 'alpha'))
@ 

At the moment the \cd{isData} method requires that each node be supplied
as an individual element of the character vector, so
\cd{pump\$isData(`x[1:3]')} would throw an error.  

\section{The \nm{modelValues} data structure}
\label{sec:modelValues-struct}

In the NIMBLE framework, \nm{modelValues} are containers designed for
storing values for models, although they can be used to store any type of information.  They may be used for model outputs or
model inputs. A modelValues object will contain \emph{rows} of
variables. Each row represents a single value of a variable from a
model and will be an array (i.e. scalar, vector, matrix or
three-dimensional array) from the same dimension\footnote{In v\ver,
  NIMBLE is limited to three dimensions.}. The simplest way to build a modelValues object is from a model object. This will create a modelValues object with the same variables as the model. 
  
<<intro-mv>>=
pumpModelValues = modelValues(pumpModel, m = 2)
pumpModel$x
pumpModelValues$x
@


  In this example, \cd{pumpModelValues} has the same variables as
  \cd{pumpModel}, although \cd{pumpModelValues} has two rows because
  we set \cd{m} to be 2. As you can see, the rows are stored as
  elements of a list.
  
  Alternatively, one can define a modelValues object manually via the \cd{ModelValuesSpec()} function. In this case, we will need to provide several arguments:
  \begin{itemize}
 \item \cd{vars}, which is a character vector of variable names, 
   \item \cd{type}, which is a character vector of the data types for each variable (`double' for real numbers, `integer' for integers) and 
     \item \cd{size}, which is a list of vectors of the sizes in each dimension of each variable. The names of the list elements must match the names provided in \cd{vars}. 
\end{itemize}

<<mvSpec>>=
mvSpec = modelValuesSpec(vars = c('a', 'b', 'c'), 
                         type = c('double', 'int', 'double'), 
                         size = list( a = 2, b =c(2,2)  , c = 1) )

customMV = modelValues(mvSpec, m = 2 )
customMV$a
@
  
Note that in R execution, the types are not enforced.  But they will
be the types created in C++ code during compilation, so they should be specified carefully.

  The object returned by \cd{modelValues()} is an uncompiled
  modelValues. When a nimbleFunction is compiled, any modelValues
  objects it uses are also compiled. A NIMBLE model always contains a
  modelValues that it uses as a default location to store its variables.

  Here is an example where the \cd{customMV} created above is used as
  the setup argument for a nimbleFunction, which is then compiled.
  Its compiled mv is then accessed with \cd{\$}.

<<resize_MV>>=
# Simple nimbleFunction that uses a modelValues object
resizeFunction_Gen <- nimbleFunction(
  setup = function(mv){},
  run = function(k = integer() ){
    resize(mv,k)})

rResize <- resizeFunction_Gen(customMV)
cResize <- compileNimble(rResize)
cCustomMV <- cResize$mv
# cCustomMV is a C++ modelValues object
@

Compiled modelValues objects can be accessed and altered in all the
same ways as uncompiled ones.  However, only uncompiled modelValues can be used as arguments to setup code in nimbleFunctions. 

\subsection{Accessing contents of modelValues}
\label{sec:access-cont-modelv}

The values in a modelValues object can be accessed in several ways
from R, and in fewer ways from NIMBLE.

<<mv-access>>=
# Sets the first row of a to (0, 1).  R only.
customMV[['a']][[1]] <- c(0,1)   

# Sets the second row of a to (2, 3)
customMV['a', 2] <- c(2,3)       

#Can access subsets of each row in standard R manner
customMV['a', 2][2] <- 4

# Accesses all values of 'a'. Output is a list.  R only.
customMV[['a']]                  

# Sets the first row of b to a matrix with values 1. R only.
customMV[['b']][[1]] <- matrix(1, nrow = 2, ncol = 2)  

# Sets the second row of b.  R only.
customMV[['b']][[2]] <- matrix(2, nrow = 2, ncol = 2)  

# Make sure the size of inputs is correct
# customMV['a', 1] <- 1:10  
# Problem: dimension of 'a' is 2, not 10!
# Will cause problems when compiling nimbleFunction using customMV
@

Currently, only the syntax \cd{customMV[`a', 2]} works in the NIMBLE
language, not \cd{customMV[[`a']][[2]]}. Also note that \cd{c()} does not work in NIMBLE, but one can do \cd{customMV[`a', 2] <- X[1:2]}.

Every row of a modelValues object is expected to be of the same
dimension. As with types, this is not enforced in R, but writing code
that changes dimensionality in R will lead to an error during compilation.

  We can query and change the number of rows using \cd{getsize()} and
  \cd{resize()}, respectively.  These work in both R and NIMBLE.  Note that we don't specify the
  variables in this case: all variables in a modelValues object will
  have the same number of rows.
  
<<resize-mv>>=
getsize(customMV)
resize(customMV, 3)
getsize(customMV)
customMV$a
@

Often it is practical to convert a modelValues object to a matrix for use in
R, such as with MCMC output for use with the tools provided by the
\cd{coda} package. This can be done with the \cd{as.matrix} method for
modelValues objects. This will generate column names by `flattening'
the variable names and indices. The rows of the modelValues will be
the rows of the matrix, with any matrices or arrays converted to a
vector based on column-major ordering.
  
<<as.matrix-mv>>=
as.matrix(customMV, 'a')   # convert 'a'
as.matrix(customMV)        # convert all variables
@

If a variable is a scalar, using \cd{unlist()} in R to extract all rows as a vector can be very useful.


<<extract_MV_Vector>>=
customMV['c', 1] <- 1
customMV['c', 2] <- 2
customMV['c', 3] <- 3
unlist(customMV['c', ])
@

Once we have a modelValues object, we can see the structure of object based on the \cd{varNames} and \cd{sizes} components of the object.

<<mv_VarNames_Sizes>>=
customMV$varNames
customMV$sizes
@

It is very important to note that, as with most NIMBLE objects,
modelValues are passed by reference, not by value. Any modifications
of modelValues objects in either R or nimbleFunctions will persist
outside of the function. This allows for more efficient computation,
as stored values are immediately shared among nimbleFunctions.

<<alter_a>>=
alter_a <- function(mv){
  mv['a',1][1] <- 1
}
customMV['a', 1]

alter_a(customMV)
customMV['a',1]

#Note that the first row was changed
@

However, when you retrieve a variable from a modelValues object, the result is a standard R list, which is subsequently passed by value, as usual in R.

\section{NIMBLE passes objects by reference}

NIMBLE relies heavily on R's Reference Class system.  When models,
modelValues, and nimbleFunctions with setup code are created, NIMBLE
generates a new, customized reference class definition for each.  As a
result, objects of these types are passed by reference and hence
modified in place by most NIMBLE operations. This is necessary to
avoid a great deal of copying and returning and having to reassign
large objects, both in processing model and nimbleFunctions  and in
running algorithms.

One cannot generally copy NIMBLE models or nimbleFunctions
(specializations or generators) in a safe fashion, because of the
references to other objects embedded within NIMBLE objects. However,
models provide a member function \cd{newModel} that will create a new
copy of the same model definition, like this:

<<copy-model>>=
newPump <- pumpModel$newModel()
@ 

This new model can then be used with newly instantiated nimbleFunctions.

The reliable way to create new copies of nimbleFunctions is to re-run
the R function called \cd{nimbleFunction()} and record the result in a
new object.

\chapter{MCMC}

\input{MCMC}

\chapter{Other algorithms provided by NIMBLE}
\label{cha:algos-provided}

In v\ver, the NIMBLE algorithm library is quite limited beyond MCMC.
It includes some basic utilities for calculating and simulating sets
of nodes.  And it includes a couple of algorithms, particle filters
and MCEM, that illustrate the
kind of programming with models that can be done with NIMBLE.

\section{Basic Utilities}
\label{sec:basic-utils}

\subsection{\cd{simNodes}, \cd{calcNodes}, and \cd{getLogProbs}}
\label{sec:cdsimn-cdcalcn-cdget}



  \cd{simNodes}, \cd{calcNodes} and \cd{getLogProb} are basic nimbleFunctions that simulate, calculate, or get the log probabilities
  (densities), respectively, of the same set of nodes each time they
  are called.  Each of these 
takes a model and a character string of node names 
  as inputs. If \cd{nodes} is left blank, then all the nodes of the model
  are used. 
  
  For \cd{simNodes}, the nodes provided are topologically sorted to 
  simulate in the correct order. For \cd{calcNodes} and \cd{getLogProb},
  the nodes are sorted and dependent nodes are included.  Recall that
 the calculations must be up to date (from a calculate call) for \cd{getLogProb} 
  to return the values you are probably looking for.
  
<<Basic_Utils_Algs>>=
simpleModelCode <- nimbleCode({
  for(i in 1:4){
    x[i] ~ dnorm(0,1)
    y[i] ~ dnorm(x[i], 1) #y depends on x
    z[i] ~ dnorm(y[i], 1) #z depends on y
    #z conditionally independent of x
  }
})

simpleModel <- nimbleModel(simpleModelCode)
cSimpleModel <- compileNimble(simpleModel)

#simulates all the x's and y's
rSimXY <- simNodes(simpleModel, nodes = c('x', 'y') ) 

#calls calculate on x and its dependents (y, but not z)
rCalcXDep <- calcNodes(simpleModel, nodes = 'x')

#calls getLogProb on x's and y's
rGetLogProbXDep <- getLogProbNodes(simpleModel,
                  nodes = 'x')

#compiling the functions
cSimXY <- compileNimble(rSimXY, project = simpleModel)
cCalcXDep <- compileNimble(rCalcXDep, project = simpleModel)
cGetLogProbXDep <- compileNimble(rGetLogProbXDep,
                           project = simpleModel)

cSimpleModel$x
cSimpleModel$y
#simulating x and y
cSimXY$run()
cSimpleModel$x
cSimpleModel$y

cCalcXDep$run()

#Gives correct answer because logProbs
#updated by 'calculate' after simulation
cGetLogProbXDep$run()

cSimXY$run()

#Gives old answer because logProbs
#not updated after 'simulate'
cGetLogProbXDep$run()
cCalcXDep$run()
@


\subsection{\cd{simNodesMV}, \cd{calcNodesMV}, and \cd{getLogProbsMV}}

There is a similar trio of nimbleFunctions that does each job
repeatedly for different rows of a modelValues object.  For example,
\cd{simNodesMV} will simulate in the model multiple times and record
each simulation in a row of its modelValues.  \cd{calcNodesMV} and
\cd{getLogProbsMV} iterate over the rows of a modelValues, copy the
nodes into the model, and then do their job of calculating or
collecting log probabilities (densities), respectively.  Each of these
returns a numeric vector with the summed log probabilities of the
chosen nodes from each
each row. \cd{calcNodesMV} will 
  save the log probabilities back into the modelValues object if
  \cd{saveLP == TRUE}, a run-time argument. 

Here are some examples:

<<Basic_Utils_MV>>=
mv <- modelValues(simpleModel)
rSimManyXY <- simNodesMV(simpleModel, nodes = c('x', 'y'), mv = mv)
rCalcManyXDeps <- calcNodesMV(simpleModel, nodes = 'x', mv = mv)
rGetLogProbMany <- getLogProbNodesMV(simpleModel,
                    nodes = 'x', mv = mv)

cSimManyXY <- compileNimble(rSimManyXY, project = simpleModel)
cCalcManyXDeps <- compileNimble(rCalcManyXDeps, project = simpleModel)
cGetLogProbMany <- compileNimble(rGetLogProbMany, project = simpleModel)

cSimManyXY$run(m = 5) # simulating 5 times
cCalcManyXDeps$run(saveLP = TRUE) # calculating 
cGetLogProbMany$run() #
@
  
  

\section{Particle filter}

  NIMBLE includes an algorithm for a basic particle filter to be used for approximating the
  log likelihood of a state-space model. At this time, the particle
  filter only works with scalar states.  A particle filter can be built
  around such a model by a call to \cd{buildParticleFilter}. This nimbleFunction requires
  setup arguments \cd{model} and \cd{orderedNodeVector}, which is the properly ordered
set of state nodes. Once this function is compiled, parameter values to the C-model should be 
  set and then the particle filter can be run by specifying the number of particles.
  
  Here is an example, using a linear state-space model for which we
  can easily calculate the likelihood using the Kalman Filter to
  verify if the particle filter seems to be working.
  
<<particle_Filter_Chunk>>=
# Building a simple linear state-space model. 
# x is latent space, y is observed data
timeModelCode <- nimbleCode({
  x[1] ~ dnorm(mu_0, 1)
	y[1] ~ dnorm(x[1], 1)
	for(i in 2:t){
		x[i] ~ dnorm(x[i-1] * a + b, 1)
		y[i] ~ dnorm(x[i] * c, 1)
	}

	a ~ dunif(0, 1)
	b ~ dnorm(0, 1)
	c ~ dnorm(1,1)
	mu_0 ~ dnorm(0, 1)
})

#simulate some data
t = 25; mu_0 = 1
x = rnorm(1 ,mu_0, 1)
y = rnorm(1, x, 1)
a = 0.5; b = 1; c = 1
for(i in 2:t){
	x[i] = rnorm(1, x[i-1] * a + b, 1)
	y[i] = rnorm(1, x[i] * c, 1)
}
## build and compile the model
rTimeModel <- nimbleModel(timeModelCode, constants = list(t = t), data = list(y = y) )
cTimeModel <- compileNimble(rTimeModel)

#Ordered list of hidden nodes. Equivalent to xTimeModel$expandNodeNames('x[1:t]')
xNodes = paste0('x[', 1:t, ']')  	

#Build the particle filter
rPF <- buildParticleFilter(rTimeModel, xNodes)
cPF = compileNimble(rPF,project = rTimeModel)

#Set parameter values
cTimeModel$mu_0 = 1
cTimeModel$a = 0.5
cTimeModel$b = 1
cTimeModel$c = 1
cTimeModel$mu_0 = 1

#Run particle filter with 
#5000 particles
cPF$run(m = 5000)
@

\section{Monte Carlo Expectation Maximization (MCEM)}

   Suppose we have a model with missing data (or a layer of latent
  variables that can be treated as missing data) and we would like to
  maximize the marginal likelihood of the model, integrating over the
  missing data. A brute-force method for doing this is MCEM. This is
  an EM algorithm in which the missing data are simulated via Monte
  Carlo (often MCMC, when the full conditional distributions cannot be
  directly sampled from) at each iteration.  MCEM can be slow, and
  there are other methods for maximizing marginal likelihoods that can
  be implemented in NIMBLE.  The reason we started with MCEM is to
  explore the flexibility of NIMBLE and illustrate the combination of
  R and NIMBLE involved, with R managing the highest-level processing
  of the algorithm and calling nimbleFunctions for computations.
  
  We will revisit the \nm{pump} example to illustrate the use of
  NIMBLE's MCEM algorithm.
  
  
<<build-MCEM>>=
pumpMCEM <- buildMCEM(model = newPump,
                      latentNodes = 'theta',
                      burnIn = 100,
                      mcmcControl = list(adaptInterval = 20),
                      boxConstraints = list( list( c('alpha', 'beta'), 
                          limits = c(0, Inf) ) ), 
                      buffer = 1e-6)
@

%  When building the MCEM algorithm, the arguments supplied are \cd{model}, \cd{latentNodes}, \cd{burnIn}, \cd{mcmcControl}, \cd{boxConstraints} and \cd{buffer}. 
  The first argument, \cd{model}, is a NIMBLE model, which can be
  either the uncompiled or compiled version. At the moment, the model provided cannot be part of another MCMC sampler.
 
  The \cd{latentNodes} argument should indicate the nodes that will be
  integrated over (sampled via MCMC), rather than
  maximized.  These
  nodes must be stochastic, not deterministic! \cd{latentNodes} will
  be expanded as described in section \ref{sec:arbitr-coll-nodes}:
  e.g., either \cd{latentNodes = `x'} or \cd{latentNodes = c(`x[1]',
    `x[2]')} will treat \cd{x[1]} and \cd{x[2]} as latent nodes if
  \cd{x} is a vector of two values. All other non-data nodes will be
  maximized over. Note that \cd{latentNodes} can include discrete nodes,
  but the nodes to be maximized cannot.  

 The \cd{burnIn} argument indicates the number of samples from the MCMC for the E-step that should be discarded when computing the expected likelihood in the M-step. Note that \cd{burnIn} can be set to values lower than in standard MCMC computations, as each iteration will start off where the last left off. 
  
The  \cd{mcmcControl} argument will be passed to \cd{configureMCMC()} to define the MCMC to be used.

 The MCEM algorithm allows for box constraints on the nodes that will
 be optimized, specified via the \cd{boxConstraints} argument. This is
 highly recommended for nodes that have zero density on parts of the
 real line\footnote{Currently NIMBLE is not able to determine this automatically.}
 Each constraint given should be a list
 in which the first element is the names of the nodes or variables
 that the constraint will be applied to and the second element is a
 vector of length 2, in which the first value is the lower limit and
 the second is the upper limit.  Values of \cd{Inf} and \cd{-Inf} are allowed. If a node is not listed, it will be assumed that there are no constraints. These arguments are passed as \cd{lower} and \cd{upper} to R's \cd{optim()} function, using \cd{method = `L-BFGS-B'}) 

 The value of the  \cd{buffer} argument shrinks the
 \cd{boxConstraints} by this amount.  This can help protect against
 non-finite values occuring when a parameter is on its boundary value. 
  
    Once the MCEM has been built for the model of interest using \cd{buildMCEM()}, it can be run as follows.

 <<run-MCEM>>=
pumpMCEM(maxit = 20, m1 = 250, m2 = 500)

pumpMCEM(maxit = 50, m1 = 1000, m2 = 5000)
@

There are three run-time arguments:
 
The \cd{maxit} argument is the number of total iterations to run the algorithm. More advanced MCEM algorithms have a stopping criteria based on computing the MCMC error. Our current draft implementation of the algorithm merely runs \cd{maxit} iterations and then terminates. 
  
  Halfway through the algorithm, the sample size used for the E-step
  switches from \cd{m1} to \cd{m2}.  This provides smaller MCMC error
  as the algorithm converges. If \cd{m1} or \cd{m2} is less than or equal to \cd{burnIn} as defined in \cd{build\_MCEM}, the MCEM algorithm will immediately quit.

  When using the MCEM algorithm, we suggest first starting with small values of \cd{m1} and \cd{m2} to get an estimate of how long the algorithm will take for larger MCMC samples. The speed of the algorithm will be linear in \cd{m2} (assuming that $m1 > m2$ as intended).



\chapter{Programming with models}
\label{cha:progr-with-models}

<<echo=FALSE>>=
read_chunk(file.path('chunks', 'programmingWithModels_chunks.R')) 
@ 



\section{Writing nimbleFunctions}
\label{sec:writ-nimble-funct}

When you write an R function, you say what the input arguments are,
you provide the code for execution, and in that code you give the
returned value\footnote{normally the value of the last
  evaluated code, or the argument to return().}.  Using the
\cd{function} keyword in R triggers the operation of
creating an object that is the function.

Creating nimbleFunctions is a little more complicated because there
are two kinds of code and two steps of execution:

\begin{enumerate}
\item \cd{Setup} code is provided as a regular R function, but the
  programmer does not control what it returns.  Normally the inputs to
  \cd{setup} code are objects like a model, a vector of nodes,
  a modelValues object or modelValuesSpec, or another nimbleFunction.  The \cd{setup} code,
  as its name implies, sets up information for run-time code.  It is
  executed in R, so it can use any aspect of R.
\item \cd{Run} code is provided in the NIMBLE language.  This is
  similar to a narrow subset of R, but it is important to remember
  that it is different and much more limited.  \cd{Run} code can
  use the objects created by the \cd{setup} code.  In addition,
  some information on variable types must be provided for input
  arguments, the return object, and in some circumstances for local
  variables. There are two
  kinds of \cd{run} code:
  \begin{enumerate}
  \item There is always a primary function, given as an argument
    called \cd{run}\footnote{This can be empty, but why do
      that?}.
  \item There can optionally be other functions, or \cd{methods} in the
    language of object-oriented programming, that share the same
    objects created by the \cd{setup} function.
  \end{enumerate}
\end{enumerate}

To fix ideas, here is a small example to illustrate the two steps of executing a nimbleFunction:

<<nf-intro>>=
@ 

The call to the R function called \cd{nimbleFunction} returns a
function, similarly to defining a function in R. That function,
\cd{logProbCalcPlus}, takes arguments for its \cd{setup} function,
executes it, and returns an object, \cd{logProbCalcPlusA}, that has a
\nm{run} member function (method) accessed by \cd{\$run}.  In this case, the
\cd{setup} function obtains the stochastic dependencies of the
\cd{node} using the \cd{getDependencies} member function of the model
(see \ref{sec:cdgetdependencies}) and stores them in
\cd{dependentNodes}.  In this way, \cd{logProbCalcPlus} can adapt to any
model.  It also creates a variable, \cd{valueToAdd}, that can be used by the nimbleFunction.

The object \cd{logProbCalcPlusA}, returned by \cd{logProbCalcPlus},
is permanently bound to the results of the processed \cd{setup}
function.  In this case, \cd{logProbCalcPlusA\$run} takes a scalar input value, \cd{P},
assigns \cd{P + valueToAdd} to
the given node in the model, and returns the sum of the log
probabilities of that node and its stochastic
dependencies\footnote{Note the use of the global assignment operator
  to assign into the model.  This is necessary for assigning into
  variables from the \cd{setup} function, at least if you want to void
  warnings from R.  These warnings come from R's reference class
  system.}.  We say  \cd{logProbCalcPlusA} is
``specialized'' or ``bound'' to the node \cd{a} and the model \cd{Rmodel}.  Usually, the
\cd{setup} code will be where information about the model
structure is determined, and then the \cd{run} code can use that
information without redundantly recomputing it.  A nimbleFunction can
be called repeatedly, each time returning a specialized nimbleFunction.
  
Readers familiar with object-oriented programming may find it useful
to think in terms of class definitions and objects.  nimbleFunction
creates a class definition.  Each specialized nimbleFunction is one object
in the class.  The setup arguments are used to define member data in
the object.

\section{Using and compiling nimbleFunctions}
\label{sec:using-comp-nimbl}

To compile the nimbleFunction, together with its model, we use \cd{compileNimble}:

<<nf-compiling>>=
@ 

These have been initialized with the values from their uncompiled
versions and can be used in the same way:

<<nf-using>>=
@ 

\subsection{Accessing and modifying numeric values from setup}
\label{sec:access-modify-numer}

While models and nodes created during \cd{setup} cannot be
modified\footnote{Actually, they can be, but only for uncompiled nimbleFunctions},
numeric values and modelValues (see below) can be.  For example:

<<nf-modifyValueToAdd>>=
@ 


\section{Compiling numerical operations with no model: omitting \cd{setup} code}
\label{sec:comp-numer-oper}

The \cd{setup} function is optional.  If it is omitted, then
\cd{nimbleFunction} is more like \cd{function}: it simply
returns a function that can be executed and compiled.  If there is no
\cd{setup} code, there is no specialization step.  This is useful
for doing math or the other kinds of processing available in NIMBLE
when no model or modelValues is needed.

<<nf-RCfun>>=
@ 

This example shows the textbook calculation of a least squares
solution for regression of 100 data points on 4 explanatory variables,
all generated randomly.  Such functions can be called from other nimbleFunctions.
In the near future, they will be able to be used in BUGS
code.\footnote{On the machine this is being written on, the compiled
  version runs a few times faster than the uncompiled version.
  However we refrain from formal speed tests because have not, for
  example, optimized the BLAS \& LAPACK available for R.}

When specifying a run-time member of a nimbleFunction, you need to
specify the types of arguments and return values, described more
below.  Since nimbleFunctions take arguments by reference, they may
modify their arguments.  However, the R interface to a nimbleFunction
performs a copy to protect the original R argument from modification.
If you want to see arguments -- potentially modified -- as well as any
return value, you can modify the \cd{control} argument to
compileNimble to include ``\cd{returnAsList = TRUE}''.  Then the
returned object will be a list with the nimbleFunction's return value
as the last element. 

If one wants a nimbleFunction that does get specialized but has
empty setup code, use \cd{setup = function() \{\}} or \cd{setup = TRUE}.

\section{Useful tools for \cd{setup} functions}

The setup function is used to determine information on nodes in a
model, set up any modelValues objects, set up any nimbleFunctions or
nimbleFunctionLists, and set up any persistent
numeric objects.  The values of numeric objects created in \cd{setup}
will persist across calls to the specialized nimbleFunction.

Some of the useful tools and objects to create in \cd{setup} functions include

\begin{description}
\item[vectors of node names] Often these are obtained from the
  \cd{getNodeNames} and \cd{getDependencies} methods of a model,
  described in section \ref{sec:cdgetn-cdgetv}.
\item[modelValues objects] These are discussed more below.
\item[specializations of other nimbleFunctions] A useful NIMBLE
  programming technique is to have one nimbleFunction contain other
  nimbleFunctions, which it can use in its run-time code.
\item[lists of other nimbleFunctions] In addition to containing single
  other nimbleFunctions, a nimbleFunction can contain a list of other
  nimbleFunctions, all defined with run-time functions that use the
  same types of arguments and return values.  These are discussed more below.
\end{description}

\subsection{Control of \cd{setup} outputs }
\label{sec:determ-pers-texttts}

Sometimes \cd{setup} code may create variables that are not used in
run-time code.  By default, NIMBLE inspects run-time code and omits
variables from \cd{setup} that do not appear in run-time code from compilation.  However, sometimes
a programmer may want to force a numeric variable to be created in
compilation, even if it is not used directly in run-time code.  As
shown below, such variables can be directly accessed in one
nimbleFunction from another, and this provides a way of using
nimbleFunctions as general data structures.  To force NIMBLE to keep
one or more
numeric variables around during compilation, for example \cd{X} and
\cd{Y}, simply include

<<eval = FALSE>>=
setupOutputs(X, Y)
@ 

anywhere in the \cd{setup} code. 

\section{NIMBLE language components}
\label{sec:nimble-lang-comp}

\subsection{Basics}
\label{sec:basics}

There are several general points that will be useful before describing
the NIMBLE language in more detail.
\begin{itemize}
\item NIMBLE language functions are not R functions.  In many cases we
  have used syntax identical or nearly so to R, and in most cases we
  have provided a matching R function, but it is important not to
  confuse the NIMBLE language definition with the behavior of the
  corresponding R function. 
  
\item NIMBLE language functions do not as a
  rule have named arguments, but some do.

\item Like R, NIMBLE uses 1-based indexing.  For example, the first
  element of a vector \cd{x} is \cd{x[1]}, not \cd{x[0]}.
   
\item To a large extent, NIMBLE functions can be executed in R
  (uncompiled) or can be compiled.  Using them in R will be slow,
  and is intended for testing and debugging algorithm logic.  At this time, the
  behavior in R will come close but will not perfectly match the behavior of the compiled
  function.  We will try to note known differences in what follows.
  
\item NIMBLE is the opposite of R for argument passing.  R nearly
  always uses pass-by-value.  NIMBLE nearly always uses
  pass-by-reference (or pointer).  Thus it is possible to write a
  nimbleFunction that returns information by modifying an argument.
  That is one important behavior that is not yet implemented in R
  execution of nimbleFunctions.

\item To understand NIMBLE compilation, it is helpful to know that anything labeled with
  a character string in R is resolved during NIMBLE compilation rather
  than being turned into a character string in C++.  For example,
  model[[node]], if node == `x', will access the variable `x' in the
  model.  However, this pairing of the model and node are resolved
  during compilation so that the C++ code makes direct access to the `x'
  object without looking it up by the character string `x' every time
  the code is executed.  That means, for example, that model[[node[i]
  ]] will not work, because it would take more work to resolve that
  during compilation.  We intend to make that work in the future -- a
  good example of a loose end in v\ver\ -- but for now it doesn't.
  
\item BUGS model nodes are implemented as nimbleFunctions with member
  functions for \cd{calculate}, \cd{simulate}, and
  \cd{getLogProb}.  There are also member functions for obtaining
  the value of each parameter or alternative parameters (e.g. rate =
  1/scale).  Because we build BUGS models using the NIMBLE language,
  we anticipate it will be possible to allow BUGS models to call
  nimbleFunctions, and for new distributions to be defined using
  nimbleFunctions.  In v\ver, we have not made that work yet.
  
\end{itemize}

\subsection{Driving models: calculate, simulate, and getLogProb}
\label{sec:driv-models:-calc}

These three functions are the primary ways to operate a model.  Their
syntax was explained in section \ref{sec:cdcalc-cdsim-cdgetl}.  For
calculate and simulate, it is usually important for the \cd{nodes}
object to be created in \cd{setup} code such that they are sorted in
topological order.

\subsection{Accessing model and modelValues variables and using \cd{copy}}
\label{sec:access-model-modelv}

The \cd{modelValues} structure was introduced in section
\ref{sec:modelValues-struct}.  Inside nimbleFunctions, modelValues are
designed to easily save values from a model object during the running
of a nimbleFunction. To access a modelValues object inside of a NIMBLE
function, the object must exist in the setup code, either by passing the modelValues object in as a setup argument or creating the object in the setup code.
  
To illustrate this, we will create a nimbleFunction for computing
importance weights for importance sampling. This function will use two
modelValues objects.  \cd{propModelValues} will contain a set of
values simulated from the importance sampling distribution and a field \cd{propLL}
for their log
probabilities (densities).  \cd{savedWeights} will contain the
difference in log probability (density) between the model and the
\cd{propLL} value provided for each set of values.   

<<mv-setup-code>>=
@
  
  The simplest way to pass values back and forth between models and
  modelValues inside of a nimbleFunction is with \cd{nimCopy}, which
  has the synonym \cd{copy}. This takes arguments 
  \begin{description}
  \item[\cd{from}, \cd{to}] which can either be models or modelValues
  \item[\cd{row}, \cd{rowTo}] which refers to the rows of a
    modelValues object, if either \cd{from} or \cd{to} is a
    modelValues. If \cd{rowTo} is omitted, it is assumed to be equal to \cd{row} if necessary.
    \item[\cd{nodes}, \cd{nodesTo}] which is a vector of the names of the nodes
      to be copied.  The node names will be expanded when variable names are provided.  If
      \cd{nodesTo} is omitted it will be set equal to \cd{nodes}.
  \end{description}
  
  Alternatively, the values may be accessed via indexing of individual
  rows, using the notation \cd{mv[var, i]}, where \cd{mv} is a
  modelValues object, \cd{var} is a variable name (not a node name),
  and \cd{i} is a row number. Likewise, the \cd{getsize} and
  \cd{resize} functions can be used as discussed previously. However the function
  \cd{as.matrix} does not work in the NIMBLE language.
  
  Here is a run-time function to use these modelValues:
  
<<mv-run-time>>=
@

Once the nimbleFunction is built, the modelValues object can be accessed
using using \cd{\$}, which is shown in more detail below.  In
fact, since modelValues, like most NIMBLE objects, are reference class
objects, one can get a reference to them before the function is
executed and then use that reference afterwards.
  
<<mv-compilation-example>>=
@

Importance sampling could also be written using simple vectors for the
weights, but we illustrated putting them in a modelValues object along
with model variables.

\subsection{Using model variables and modelValues in expressions}
\label{sec:using-model-variable}

Each way of accessing a variable, node, or modelValues can be used amid mathematical
expressions, including with indexing, or passed to another
nimbleFunction as an argument.  For example, the following two
statements would be valid:

<<eval = FALSE>>=
model[['x[2:8, ]']][2:4, 1:3] %*% Z
@ 
if Z is a vector or matrix, and

<<eval = FALSE>>=
C[6:10] <- mv[v, i][1:5, k] + B
@ 
if B is a vector or matrix.

The NIMBLE language allows scalars, but BUGS models never have purely
scalar nodes.  Instead, a single node such as defined by \cd{z $\sim$
  dnorm(0, 1)} is implemented as a vector of length 1, similar to R.
When using z via \cd{model\$z} or \cd{model[[`z']]}, NIMBLE
will try to do the right thing by treating this as a scalar.  In the
event of problems\footnote{please tell us!}, a more explicit way to
access z is \cd{model\$z[1]} or \cd{model[[`z']][1]}.

\subsection{Getting and setting more than one model node or variable at a time}
\label{sec:getting-setting-more}

Sometimes it is useful to set a collection of nodes or variables at
one time.  For example, one might want a nimbleFunction that will
serve as the objective function for an optimizer.  The input to the
nimbleFunction would be a vector, which should be used to fill a
collection of nodes in the model before calculating their log
probabilities.  NIMBLE has two ways to do this, one of which was set
up during development and may be deprecated in the future.

The recommended newer way is:

<<eval=FALSE>>=
P <- values(model, nodes)
values(model, nodes) <- P
@ 

where the first line would assign the collection of values from nodes
into P, and the second would to the inverse.  In both cases, values
from nodes with 2 or more dimensions are flattened into a vector in
column-wise order.

The older syntax, which may be deprecated in the future, is

<<eval=FALSE>>=
getValues(P, model, nodes)
setValues(P, model, nodes)
@ 

These are equivalent to the two previous lines.  Note that
\cd{getValues} modifies P in the calling environment.

With the new notation, \cd{values(model, nodes)} may appear as a
vector in other expressions, e.g. \cd{Y <- A \%*\% values(model,
  nodes) + b}. 

\subsection{Basic flow control: if-then-else, for, and while}
\label{sec:basic-flow-control}

These basic control flow structures use the same syntax as in R.
However, \cd{for}-loops are limited to sequential integer
indexing.  For example, \cd{for(i in 2:5) \{...\} } works as it does
in R.  Decreasing index sequences are not allowed.  

In v\ver, there is support for iterating over indices of a
nimbleFunctionList using \cd{seq\_along} as in R.  This is
described below.

\subsection{How numeric types work}
\label{sec:how-types-work}

Numeric types in NIMBLE are much less flexible than in R, a reflection
of the fact that NIMBLE code can be compiled into C++\footnote{C++ is a
  statically typed language, which means the type of a variable cannot
  change.}.  In NIMBLE, the \textit{type} of a numeric object refers to the number
of dimensions and the numeric type of the elements.  In v\ver, objects
from 0 (scalar) to 3 dimensions are supported, and the numeric types
integer and double are supported. In addition the type logical is
supported for scalars only.  While the number of dimensions
cannot change during run-time, numeric objects can be resized using
\cd{setSize} or by full (non-indexed) assignment.

When possible, NIMBLE will determine the type of a variable for you.
In other cases you must declare the type.  The rules are as follows:

\begin{itemize}
\item For numeric variables from the \cd{setup} function that
  appear in the \cd{run} function or other member functions (or
  are declared in \cd{setupOutputs}): the
  type is determined from the values created by the \cd{setup}
  code.  Note that the types created by \cd{setup} code must be
  consistent across all specializations of the nimbleFunction.  For
  example if X is created as a matrix (2-dimensional double) in one
  specialization but as a vector (1-dimensional double) in another, there
  will be a problem during compilation.  The sizes may differ in each specialization.
  
  Treatment of vectors of length 1 presents special challenges because
  they could be treated as scalars or vectors.  Currently they are
  treated as scalars.  If you want a vector, ensure that the length is
  greater than 1 in the setup code and the use \cd{setSize} in the
  run-time code.

\item In \cd{run} code, when a numeric variable is created by
  assignment, its type is determined by that assignment.  Subsequent
  uses of that variable must be consistent with that type. 
  
\item If the first uses of a variable involve indexing, the type must
  be declared explicitly, using \cd{declare}, before using it.  In addition, its size must
  be set before assigning into it.  Sizes can be included in the
  declare() statement, but if so they should not subsequently change.
  If a variable may have its size changed during execution, then the
  declare statement should omit the size argument, and a separate call
  to \cd{setSize} should be used to set the initial size(s).
\end{itemize}

\subsection{Declaring argument types and the return type}
\label{sec:decl-argum-types}

NIMBLE requires that types of arguments and a return type be
explicitly declared.

The syntax for a type declaration is:
\begin{itemize}
\item \cd{type(nDim, sizes)}
\end{itemize}

\cd{type} can currently take values \cd{double},
\cd{integer}, or, for scalars only, \cd{logical}.  In a
\cd{returnType} statement, a type of \cd{void()} is valid, but you
won't usually include that because it is the default if no
\cd{returnType} statement is included.
\cd{nDim} is the number of dimensions, with 0 indicating scalar.
\cd{sizes} is an optional vector of fixed, known sizes.  These
should use R's \cd{c} function if \cd{nDim} $>1$.  If sizes
are omitted, they will either be set when the entire object is
assigned to, or an explicit call to \cd{setSize} is needed.

\subsection{Querying and changing sizes}
\label{sec:query-chang-sizes}

Sizes can be queried as follows:
\begin{itemize}
\item \cd{length()} behaves like R's \cd{length()} function.  It
  returns the \textit{entire} length of X.  That means if X is
  multivariate, \cd{length} returns the product of the sizes in
  each dimension.
\item \cd{nimbleDim()} behaves like R's \cd{dim()} function for
  matrices or arrays, and like R's \cd{length()} function for
  vectors.  In other words, regardless of whether the number of
  dimensions is 1 or more, it returns a vector of the sizes.  The
  keyword \cd{dim()} is a valid substitute for \cd{nimbleDim()},
  but if you use it you should recognize it behaves differently from
  R's \cd{dim()}. 
  \begin{itemize}
  \item A quirky limitation in v\ver: It not currently possible to
    assign the results from \cd{nimbleDim()} to another object using
    vector assignment.  So the only practical way to use
    \cd{nimbleDim()} is to extract elements immediately, such as
    \cd{nimbleDim(X)[1]}, \cd{nimbleDim(X)[2]}, etc.
  \end{itemize}
\end{itemize}

Sizes can be changed using:
\begin{itemize}
\item setSize(X, sizes)
\end{itemize}
where \cd{sizes} is a scalar if \cd{X} is 1-dimensional and uses R's \cd{c()}
function to provide a vector of sizes if X is more than 1-dimensional.

\subsection{Basic math and linear algebra}
\label{sec:basic-math-linear}

NIMBLE uses the \nm{Eigen} library in C++ to accomplish linear algebra.  In
v\ver, we use a lot of Eigen's capabilities, but not all of them.  The
supported operations are given in tables \ref{table:functions}-\ref{table:functions-matrix}.

No vectorized operations other than assignment are supported for more
than two dimensions in
v\ver.  That means \cd{A = B + C} will work only if B and C have dimensions
$\le$ 2.

\subsubsection{Managing dimensions and sizes: asRow, asCol, and dropping dimensions}
\label{sec:manag-dimens-sizes}

It can be tricky to determine the dimensions returned by a linear
algebra expression.  As much as possible, NIMBLE behaves like R, but
in some cases this is not possible because R uses run-time information
while NIMBLE must determine dimensions at compile-time.

Suppose v1 and v2 are vectors, and M1 is a matrix.  Then

\begin{itemize}
\item  \cd{v1 + M1} generates a compilation error unless one dimension of
M1 is known at compile-time to be 1.  If so, then v1 is promoted to a
1-row or 1-column matrix to conform with M1, and the result is a
matrix of the same sizes.  This behavior occurs for
all component-wise binary functions.

\item \cd{ v1 \%*\% M1} defaults to promoting v1 to a 1-row matrix,
  unless it is known at compile-time that M1 has 1 row, in which case
  v1 is promoted to a 1-column matrix.

\item \cd{ M1 \%*\% v1} defaults to promoting v1 to a 1-column matrix,
unless it is known at compile time that M1 has 1 column, in which case
v1 is promoted to a 1-row matrix.

\item \cd{ v1 \%*\% v2} promotes v1 to a 1-row matrix and v2 to a
1-column matrix, so the returned values is a 1x1 matrix with the inner
product of v1 and v2.

\item \cd{asRow(v1)} explicitly promotes v1 to a 1-row matrix.
  Therefore \cd{v1 \%*\% asRow(v2)} gives the outer product of
  v1 and v2.
  
\item \cd{asCol(v1)} explicitly promotes v1 to a 1-column matrix.  
  
\item The default promotion for a vector is to a 1-column matrix.
  Therefore, \cd{v1 \%*\% t(v2)} is equivalent to \cd{v1 \%*\% asRow(v2)} .

\item When indexing, dimensions with scalar indices will be dropped.
  For example, \cd{M1[1,]} and \cd{M1[,1]} are both vectors.
  
\item The left-hand side of an assignment can use indexing, but if so
  it must already be correctly sized for the result.  For example,
  \cd{Y[5:10, 20:30] <- model\$x} will not work -- and could crash
  your R session with a segmentation fault --  if Y is not
  already at least 10x30 in size.
  
\end{itemize}

Here are some examples to illustrate the above points, assuming M2 is
a square matrix.

\begin{itemize}
\item \cd{Y <- v1 + M2 \%*\% v2} will
  return a 1-column matrix.  If Y is created by this statement, it
  will be a 2-dimensional variable.  If Y already exists, it must
  already be 2-dimesional, and it will be automatically re-sized for
  the result.
\item \cd{Y <- v1 + (M2 \%*\% v2)[,1]} will return a vector.  Y
  will either be created as a vector or must already exist as a vector
  and will be re-sized for the result.
\end{itemize}

\subsubsection{Size warnings and the potential for crashes}
\label{sec:size-warn-potent}

For matrix algebra, NIMBLE cannot ensure perfect behavior because
sizes are not known until run-time.  Therefore, it is possible for you
to write code that will crash your R session.  In v\ver, NIMBLE
attempts to issue warning if sizes are not compatible, but it does not
halt execution.  Therefore, if you execute \cd{A <- M1 \% * \%
  M2}, and M1 and M2 are not compatible for matrix multiplication,
NIMBLE will output a warning that the number of rows of M1 does not
match the number of columns of M2.  After that warning the statement
will be executed and may result in a crash.  Another easy way to write
code that will crash is to do things like \cd{Y[5:10, 20:30] <-
  model\$x} without ensuring Y is at least 10x30.  In the future we hope to
prevent crashes, but in v\ver\ we limit ourselves to trying to provide
useful information.

\subsection{Including other methods in a nimbleFunction}
\label{sec:incl-other-meth}

Other methods can be included with the \cd{methods} argument to
\cd{nimbleFunction}.  These methods can use the objects created in
\cd{setup} code in just the same ways as the \cd{run} function.  In
fact, the \cd{run} function is just a method that has the special
status of executing when the specialized nimbleFunction object is
used like a function.  Within a nimbleFunction, other methods are
called just like a regular function.  When one nimbleFunction calls a
method of another nimbleFunction other than \cd{run}, it does so via
\cd{\$}, as illustrated in the following.

<<usingMemberFunctions>>=
@ 

\subsection{Using other nimbleFunctions}
\label{sec:using-other-nimbl}

One nimbleFunction can use another nimbleFunction that was passed to
it as a setup argument or was created in the setup function.  This can
be an effective way to program.  When a nimbleFunction needs to
access a setup variable or method of another nimbleFunction, use
\cd{\$}. 

<<owningMemberFunctions>>=
@ 

Note that the output from the \cd{print} calls in the compiled
function match those from
the uncompiled function when run in an R session.  It is not shown here
due to how R and \cd{knitr} manage such output.

\subsection{Virtual nimbleFunctions and nimbleFunctionLists}
\label{sec:virt-nimbl-nimbl}

Often it is useful for one nimbleFunction to have a list of other
nimbleFunctions that have methods with the same arguments and return
types.  For example, NIMBLE's MCMC contains a list of samplers that
are each nimbleFunctions.

To make such a list, NIMBLE provides a way to declare the arguments
and return types of methods: virtual nimbleFunctions created by
\cd{nimbleFunctionVirtual}.  Other nimbleFunctions can inherit from
virtual nimbleFunctions, which in R is called containing them.
Readers familiar with object oriented programming will recognize this
as a simple class inheritance system.  In v\ver\ it is limited to
simple, single-level inheritance.

Here is how it works:

<<nimbleFunctionLists>>=
@ 


As in R, the
\cd{seq\_along} function is equivalent to
\cd{1:length(nimFunList)} if \cd{length(nimFunList)} $>$ 0, and
it is an empty sequence if \cd{length(nimFunList)} == 0.

Currently \cd{seq\_along} works only for nimbleFunctionLists.

Virtual nimbleFunctions cannot define \cd{setup} values to be inherited.

\subsection{print}
\label{sec:print}

As demonstrated above, the NIMBLE function \cd{print}, or equivalently
\cd{nimPrint}, prints an
arbitrary set of outputs in order.  Again, this output is not able to
be included in this document from compiled models due to how R and
\cd{knitr} work.

\subsection{Alternative keywords for some functions}
\label{sec:altern-keyw-some}

NIMBLE uses some keywords, such as \cd{dim} and \cd{print}, in ways
similar to but not the same as R. In addition, there are some keywords
in NIMBLE that have the same names as really different R functions.
For example, \cd{step} is part of the BUGS language, but it is also an
R function for stepwise model selection.  And \cd{equals} is part of
the BUGS language but is also used in the \cd{testthat} package, which
we use in testing NIMBLE.

The way NIMBLE handles this to try to avoid conflicts is to replace
some keywords immediately upon creating a nimbleFunction.  These
replacements include
\begin{itemize}
\item \cd{copy} $\rightarrow$ \cd{nimCopy}
\item \cd{dim}  $\rightarrow$ \cd{nimbleDim}
\item \cd{print} $\rightarrow$ \cd{nimPrint}
\item \cd{step} $\rightarrow$ \cd{nimbleStep}
\item \cd{equals} $\rightarrow$ \cd{nimbleEquals}
\end{itemize}

This system give programmers the choice between using the keywords like
\cd{nimPrint} directly, to avoid confusion in their own code about
which ``print'' is being used, or to use the more intuitive keywords
like \cd{print} but remember that they are not the same as R's functions.

\subsection{User-defined data structures}
\label{sec:user-defined-data}

NIMBLE does not currently have user-defined data structures, but one
can use nimbleFunctions to achieve a similar effect.  To do so, one
can define setup code with whatever variables are wanted and ensure
they are compiled using \cd{setupOutputs}.  Here is an example:

<<dataStructures>>=
@ 

You'll notice that 
\begin{itemize}
\item after execution of the compiled function, access to
the \cd{X}, \cd{Y}, and \cd{Z} is not yet quite the same as for the
uncompiled case.  
\item We need to take care that at the time of compilation, the
  \cd{X}, \cd{Y} and \cd{Z} values contains doubles via
  \cd{as.numeric} so that they are not compiled as integer objects.
\item The \cd{myDataNF} could be created in the setup code.  We just
  provided it as a setup argument to illustrate that option.
\end{itemize}

\subsection{distribution functions}
\label{sec:nimble-dist-funs}

Distribution ``d'' and ``r'' functions can be used from
nimbleFunctions, although at the moment they are neither as flexible
nor as standard as in NIMBLE's processing of BUGS models.  In
particular, only one parameterization is used, and it is the canonical
one used ultimately for compiling.  These are listed next:
\begin{itemize}
\item \cd{dbinom(size, prob)}
\item \cd{dcat(prob)}
\item \cd{dmulti(size, prob)}
\item \cd{dnbinom(prob, size)}
\item \cd{dpois(lambda)}
\item \cd{dbeta(shape1, shape2)}
\item \cd{dchisq(df)}
\item \cd{dexp(rate)}
\item \cd{dgamma(shape, scale)}
\item \cd{dlnorm(meanlog, sdlog)}
\item \cd{dlogis(location, scale)}
\item \cd{dnorm(mean, sd)}
 \item \cd{dt\_nonstandard(df, mu, sigma)}
 \item \cd{dweibull(shape, scale)}
  \item \cd{ddirch(alpha)}
  \item \cd{dmnorm\_chol(mean, chol, prec\_param)}
  \item \cd{dwish\_chol(chol, df, scale\_param)}
\end{itemize}

In the last two, chol stands for Cholesky decomposition; 
prec\_param indicates whether the Cholesky is of a precision matrix or covariance
matrix; and scale\_param indicates whether the Cholesky is of a scale
matrix or an inverse scale matrix.

To call a ``d'' function, the variable (usually ``x'' in R) must be
included as the first argument.  To call the ``r'' function, a 1 must
be included as the first argument.  We'll make these more standard and
flexible, and include ``q'' and ``p'' functions, in the future.

\chapter{Additional and advanced topics}
\label{cha:topics}


\section{Cautions and suggestions}

\begin{itemize}
\item When the value of a stochastic node changes, the values of any
  deterministics nodes that depend on that node are NOT
  automatically updated. In nimbleFunctions or when manipulating
  models from R, one must use \cd{calculate()} (or \cd{simulate()}
  called on the relevant deterministic nodes) to update the values of
  the dependent nodes.
\item Similarly, \cd{getLogProb} should only be used when one is sure
  the current log probabilities are up to date.  If you assign new
  values to nodes, you must call \cd{calculate} on them to update the
  log probabilities. 
\item We have tried to make NIMBLE's handling of mutlivariate objects
  flexible, but how you choose to set things up could affect
  computational efficiency.  We'll explore that more in the future.
\end{itemize}
\section{Parallel processing}

Eigen and NIMBLE's distribution functions (which use BLAS and LAPACK) can use multiple threads if enabled on your system. In general one can control this using the \nm{OMP\_NUM\_THREADS} environment variable. For parallelized distribution functions, one needs a threaded BLAS installed on your system, with R linked to that BLAS. 

We will be exploring providing additional parallelization tools in NIMBLE, in particular parallel for loops, analogous to \cd{foreach}. 


\end{document}
