library(knitr)
pwd()
library(nimble)
if(!require(nimble, warn.conflicts = FALSE, quietly = TRUE)) {
#source(file.path('..', '..', 'examples', 'demos', 'loadAllCode.R'))
}
require(methods, warn.conflicts = FALSE, quietly = TRUE)  # seems to be needed, but why?
require(igraph, warn.conflicts = FALSE, quietly = TRUE)  # same question
@
mcmcspec <- MCMCspec(Rmodel)
mcmcspec <- configureMCMC(Rmodel)
litters_code <- nimbleCode({
for (i in 1:G) {
a[i] ~ dgamma(1, .001)
b[i] ~ dgamma(1, .001)
for (j in 1:N) {
r[i,j] ~ dbin(p[i,j], n[i,j])
p[i,j] ~ dbeta(a[i], b[i])
}
mu[i] <- a[i] / (a[i] + b[i])
theta[i] <- 1 / (a[i] + b[i])
}
})
## list of fixed constants
constants <- list(G = 2,
N = 16,
n = matrix(c(13, 12, 12, 11, 9, 10, 9,  9, 8, 11, 8, 10, 13,
10, 12, 9, 10,  9, 10, 5,  9,  9, 13, 7, 5, 10, 7,  6,
10, 10, 10, 7), nrow = 2))
## list specifying model data
data <- list(r = matrix(c(13, 12, 12, 11, 9, 10,  9, 9, 8, 10, 8, 9, 12, 9,
11, 8, 9,  8,  9,  4, 8,  7, 11, 4, 4, 5 , 5, 3,  7, 3,
7, 0), nrow = 2))
## list specifying initial values
inits <- list(p = matrix(0.5, nrow = 2, ncol = 16))
## build the R model object
Rmodel <- nimbleModel(litters_code,
constants = constants,
data      = data,
inits     = inits)
###########################################
##### MCMC specification and building #####
###########################################
## generate the default MCMC specification;
## only wish to monitor the derived quantity 'mu'
mcmcspec <- configureMCMC(Rmodel, monitors = 'mu')
## check the samplers assigned by default MCMC specification
mcmcspec$getSamplers()
## double-check our monitors, and thinning interval
mcmcspec$getMonitors()
## build the executable R MCMC function
mcmc <- buildMCMC(mcmcspec)
## let's try another MCMC, as well,
## this time using the crossLevel sampler for top-level nodes
## generate an empty MCMC specification
## we need a new copy of the model to avoid compilation errors
Rmodel2 <- Rmodel$newModel()
mcmcspec_CL <- MCMCspec(Rmodel2, nodes = NULL, monitors = 'mu')
## add two crossLevel samplers
mcmcspec_CL$addSampler(type = 'crossLevel',
control = list(topNodes = c('a[1]', 'b[1]')))
mcmcspec_CL$addSampler(type = 'crossLevel',
control = list(topNodes = c('a[2]', 'b[2]')))
## let's check the samplers
mcmcspec_CL$getSamplers()
## build this second executable R MCMC function
mcmc_CL <- buildMCMC(mcmcspec_CL)
###################################
##### compile to C++, and run #####
###################################
## compile the two copies of the model
Cmodel <- compileNimble(Rmodel)
Cmodel2 <- compileNimble(Rmodel2)
## compile both MCMC algorithms, in the same
## project as the R model object
## NOTE: at this time, we recommend compiling ALL
## executable MCMC functions together
Cmcmc <- compileNimble(mcmc, project = Rmodel)
Cmcmc_CL <- compileNimble(mcmc_CL, project = Rmodel2)
## run the default MCMC function,
## and example the mean of mu[1]
Cmcmc$run(1000)
cSamplesMatrix <- as.matrix(nfVar(Cmcmc, 'mvSamples'))
mean(cSamplesMatrix[, 'mu[1]'])
## run the crossLevel MCMC function,
## and examine the mean of mu[1]
Cmcmc_CL$run(1000)
cSamplesMatrix_CL <- as.matrix(nfVar(Cmcmc_CL, 'mvSamples'))
mean(cSamplesMatrix_CL[, 'mu[1]'])
litters_code <- nimbleCode({
for (i in 1:G) {
a[i] ~ dgamma(1, .001)
b[i] ~ dgamma(1, .001)
for (j in 1:N) {
r[i,j] ~ dbin(p[i,j], n[i,j])
p[i,j] ~ dbeta(a[i], b[i])
}
mu[i] <- a[i] / (a[i] + b[i])
theta[i] <- 1 / (a[i] + b[i])
}
})
## list of fixed constants
constants <- list(G = 2,
N = 16,
n = matrix(c(13, 12, 12, 11, 9, 10, 9,  9, 8, 11, 8, 10, 13,
10, 12, 9, 10,  9, 10, 5,  9,  9, 13, 7, 5, 10, 7,  6,
10, 10, 10, 7), nrow = 2))
## list specifying model data
data <- list(r = matrix(c(13, 12, 12, 11, 9, 10,  9, 9, 8, 10, 8, 9, 12, 9,
11, 8, 9,  8,  9,  4, 8,  7, 11, 4, 4, 5 , 5, 3,  7, 3,
7, 0), nrow = 2))
## list specifying initial values
inits <- list(p = matrix(0.5, nrow = 2, ncol = 16))
## build the R model object
Rmodel <- nimbleModel(litters_code,
constants = constants,
data      = data,
inits     = inits)
###########################################
##### MCMC specification and building #####
###########################################
## generate the default MCMC specification;
## only wish to monitor the derived quantity 'mu'
mcmcspec <- configureMCMC(Rmodel, monitors = 'mu')
## check the samplers assigned by default MCMC specification
mcmcspec$getSamplers()
## double-check our monitors, and thinning interval
mcmcspec$getMonitors()
## build the executable R MCMC function
mcmc <- buildMCMC(mcmcspec)
## let's try another MCMC, as well,
## this time using the crossLevel sampler for top-level nodes
## generate an empty MCMC specification
## we need a new copy of the model to avoid compilation errors
Rmodel2 <- Rmodel$newModel()
mcmcspec_CL <- configureMCMC(Rmodel2, nodes = NULL, monitors = 'mu')
## add two crossLevel samplers
mcmcspec_CL$addSampler(type = 'crossLevel',
control = list(topNodes = c('a[1]', 'b[1]')))
mcmcspec_CL$addSampler(type = 'crossLevel',
control = list(topNodes = c('a[2]', 'b[2]')))
## let's check the samplers
mcmcspec_CL$getSamplers()
## build this second executable R MCMC function
mcmc_CL <- buildMCMC(mcmcspec_CL)
###################################
##### compile to C++, and run #####
###################################
## compile the two copies of the model
Cmodel <- compileNimble(Rmodel)
Cmodel2 <- compileNimble(Rmodel2)
## compile both MCMC algorithms, in the same
## project as the R model object
## NOTE: at this time, we recommend compiling ALL
## executable MCMC functions together
Cmcmc <- compileNimble(mcmc, project = Rmodel)
Cmcmc_CL <- compileNimble(mcmc_CL, project = Rmodel2)
## run the default MCMC function,
## and example the mean of mu[1]
Cmcmc$run(1000)
cSamplesMatrix <- as.matrix(nfVar(Cmcmc, 'mvSamples'))
mean(cSamplesMatrix[, 'mu[1]'])
## run the crossLevel MCMC function,
## and examine the mean of mu[1]
Cmcmc_CL$run(1000)
cSamplesMatrix_CL <- as.matrix(nfVar(Cmcmc_CL, 'mvSamples'))
mean(cSamplesMatrix_CL[, 'mu[1]'])
