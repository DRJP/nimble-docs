% To avoid execution of code, do opts_chunk$set(eval = FALSE)
% Or in shell to make NimbleUserManualNoEval.pdf
\documentclass[12pt,oneside]{book}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{bbding}
\usepackage[unicode=true]{hyperref}
\usepackage{multirow}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{verbatim}
\geometry{tmargin = 1in, bmargin = 1in, lmargin = 1in, rmargin = 1in}

\def\file#1{\textsl{#1}}

\def\cd#1{\texttt{#1}}
\def\nm#1{\textit{#1}}
\newcommand{\ver}{0.4}

\hypersetup{colorlinks=true, linkcolor=red}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}
%\SweaveOpts{concordance=TRUE}
%\SweaveOpts{concordance=TRUE}




\title{NIMBLE User Manual}
\author{NIMBLE Development Team}
\date{Version \ver}
\maketitle



\begingroup
\hypersetup{linkcolor=blue}
%\hypersetup{linkcolor=green,pdfborderstyle={/S/U/W 1}}
\tableofcontents
\endgroup


%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr



\chapter{Welcome to NIMBLE}
\label{sec:welcome-nimble}

NIMBLE is a system for building and sharing analysis methods for
statistical models, especially for hierarchical models and
computationally-intensive methods.  This is an early version,
\ver. You can do quite a bit with it, but you can also expect it to be rough
and incomplete.  If you want to analyze data, we hope you will find
something already useful.  If you want to build algorithms, we hope
you will program in NIMBLE and make an R package providing your
method.  We also hope you will join the mailing lists
(\href{http://R-nimble.org}{R-nimble.org}) and help improve NIMBLE by
telling us what you want to do with it, what you like, and what could
be better.  We have a lot of ideas for how to improve it, but we want
your help and ideas too.

\section{Why something new?}
\label{sec:why-something-new}

There is a lot of statistical software out there.  Why did we build
something new?  More and more, statistical models are being customized
to the details of each project.  That means it is often difficult to
find a package whose set of available models and methods includes what
you need.  And more and more, statistical models are hierarchical,
meaning they have some unobserved random variables between the
parameters and the data.  These may be random effects, shared
frailties, latent states, or other such things.  Or a model may be
hierarchical simply due to putting Bayesian priors on parameters.
Except for simple cases, hierarchical statistical models are often
analyzed with computationally-intensive algorithms, the best known of
which is Markov chain Monte Carlo (MCMC).

Several existing software systems have become widely used by
providing a flexible way to say what the model is and then
automatically providing an algorithm such as MCMC.  When these work,
and when MCMC is what you want, that's great.  Unfortunately, there
are a lot of hard models out there for which default MCMCs don't work
very well.  And there are also a lot of useful new and old algorithms that
are not MCMC.  That's why we wanted to create a system that combines a
flexible system for model specification -- the BUGS language -- with
the ability to program with those models.  That's the goal of NIMBLE.

\section{What does NIMBLE do?}
\label{sec:what-is-nimble}

NIMBLE stands for Numerical Inference of statistical Models for Bayesian and
Likelihood Estimation.  Although NIMBLE was motivated by algorithms
for hierarchical
statistical models, you could use it for
simpler models too.

You can think of NIMBLE as comprising three pieces:

\begin{enumerate}
\item A system for writing statistical models flexibly, which is an
  extension of the BUGS language\footnote{But see Section
    \ref{sec:not-yet-supported} for information about limitations and
    extensions to how NIMBLE handles BUGS right now.}.
\item A library of algorithms such as MCMC.
\item A language, called NIMBLE, embedded within and similar in style
  to R, for writing algorithms that operate on BUGS models.
\end{enumerate}

Both BUGS models and NIMBLE algorithms are automatically processed
into C++ code, compiled, and loaded back into R with seamless
interfaces.  

Since NIMBLE can compile R-like functions into C++ that use the Eigen
library for fast linear algebra, it can be useful for making fast
numerical functions with or without BUGS models involved\footnote{The
 packages Rcpp and RcppEigen provide different ways of
  connecting C++, the Eigen library and R.  In those packages you
  program directly in C++, while in NIMBLE you program in an R-like
  fashion and the NIMBLE compiler turns it into C++.  Programming
  directly in C++ allows full access to C++, while programming in
  NIMBLE allows simpler code.}

One of the beauties of R is that many of the high-level analysis
functions are themselves written in R, so it is easy to see their code and modify
them.  The same is true for NIMBLE: the algorithms are themselves
written in the NIMBLE language.

\section{How to use this manual}
We emphasize that you can use NIMBLE for data analysis with the
algorithms provided by NIMBLE without ever using the NIMBLE language
to write algorithms. So as you get started, feel free to focus on
Chapters \ref{cha:intro}-\ref{cha:algos-provided}.  The algorithm
library in v\ver\ is just a start, so we hope you'll let us know what
you want to see and consider writing it in NIMBLE.  More about NIMBLE
programming comes in \ref{cha:progr-with-models}.
%%  <<chWelcome, child='chapter_WelcomeToNimble.Rnw'>>=
%%  @ 


%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr







\chapter{Lightning introduction}
\label{cha:intro}

\section{A brief example}
\label{sec:brief-example}

Here we'll give a simple example of building a model and running some algorithms on the model, as well as creating our own user-specified algorithm. The goal is to give you a sense for what one can do in the system. Later sections will provide more detail.

We'll use the \nm{pump} model example from BUGS\footnote{The data set
  describes failure times of some pumps.}. As you'll see later, we can
read the model into NIMBLE from the files provided as the
BUGS example but for now, we'll enter it directly in R.

In this ``lightning introduction'' we will:

\begin{enumerate}
\item Create the model for the pump example.
\item Compile the model.
\item Create a basic MCMC specification for the pump model.
\item Compile and run the MCMC
\item Customize the MCMC specification and compile and run that.
\item Create, compile and run a Monte Carlo Expectation Maximization (MCEM)
  algorithm, which illustrates some of the flexibility NIMBLE
  provides to combine R and NIMBLE.
\item Write a short \cd{nimbleFunction} to generate simulations from
  designated nodes of any  model.
\end{enumerate}


\section{Creating a model}

First we define the model code, its constants, data, and initial
values for MCMC.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pumpCode} \hlkwb{<-} \hlkwd{nimbleCode}\hlstd{(\{}
  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{N)\{}
      \hlstd{theta[i]} \hlopt{~} \hlkwd{dgamma}\hlstd{(alpha,beta);}
      \hlstd{lambda[i]} \hlkwb{<-} \hlstd{theta[i]}\hlopt{*}\hlstd{t[i];}
      \hlstd{x[i]} \hlopt{~} \hlkwd{dpois}\hlstd{(lambda[i])}
  \hlstd{\}}
  \hlstd{alpha} \hlopt{~} \hlkwd{dexp}\hlstd{(}\hlnum{1.0}\hlstd{);}
  \hlstd{beta} \hlopt{~} \hlkwd{dgamma}\hlstd{(}\hlnum{0.1}\hlstd{,}\hlnum{1.0}\hlstd{);}
\hlstd{\})}

\hlstd{pumpConsts} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{N} \hlstd{=} \hlnum{10}\hlstd{,}
               \hlkwc{t} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{94.3}\hlstd{,} \hlnum{15.7}\hlstd{,} \hlnum{62.9}\hlstd{,} \hlnum{126}\hlstd{,} \hlnum{5.24}\hlstd{,}
                 \hlnum{31.4}\hlstd{,} \hlnum{1.05}\hlstd{,} \hlnum{1.05}\hlstd{,} \hlnum{2.1}\hlstd{,} \hlnum{10.5}\hlstd{))}

\hlstd{pumpData} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{x} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{5}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{5}\hlstd{,} \hlnum{14}\hlstd{,} \hlnum{3}\hlstd{,} \hlnum{19}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{1}\hlstd{,} \hlnum{4}\hlstd{,} \hlnum{22}\hlstd{))}

\hlstd{pumpInits} \hlkwb{<-} \hlkwd{list}\hlstd{(}\hlkwc{alpha} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{beta} \hlstd{=} \hlnum{1}\hlstd{,}
              \hlkwc{theta} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{0.1}\hlstd{, pumpConsts}\hlopt{$}\hlstd{N))}
\end{alltt}
\end{kframe}
\end{knitrout}

Now let's create the model and look at some of its nodes.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pump} \hlkwb{<-} \hlkwd{nimbleModel}\hlstd{(}\hlkwc{code} \hlstd{= pumpCode,} \hlkwc{name} \hlstd{=} \hlstr{'pump'}\hlstd{,} \hlkwc{constants} \hlstd{= pumpConsts,}
                    \hlkwc{data} \hlstd{= pumpData,} \hlkwc{inits} \hlstd{= pumpInits)}

\hlstd{pump}\hlopt{$}\hlkwd{getNodeNames}\hlstd{()}
\end{alltt}
\begin{verbatim}
##  [1] "alpha"               "beta"               
##  [3] "lifted_d1_over_beta" "theta[1]"           
##  [5] "theta[2]"            "theta[3]"           
##  [7] "theta[4]"            "theta[5]"           
##  [9] "theta[6]"            "theta[7]"           
## [11] "theta[8]"            "theta[9]"           
## [13] "theta[10]"           "lambda[1]"          
## [15] "lambda[2]"           "lambda[3]"          
## [17] "lambda[4]"           "lambda[5]"          
## [19] "lambda[6]"           "lambda[7]"          
## [21] "lambda[8]"           "lambda[9]"          
## [23] "lambda[10]"          "x[1]"               
## [25] "x[2]"                "x[3]"               
## [27] "x[4]"                "x[5]"               
## [29] "x[6]"                "x[7]"               
## [31] "x[8]"                "x[9]"               
## [33] "x[10]"
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlstd{x}
\end{alltt}
\begin{verbatim}
##  [1]  5  1  5 14  3 19  1  1  4 22
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlstd{alpha}
\end{alltt}
\begin{verbatim}
## [1] 1
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlstd{theta}
\end{alltt}
\begin{verbatim}
##  [1] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
\end{verbatim}
\end{kframe}
\end{knitrout}


Notice that
in the list of nodes, NIMBLE has introduced a new node,
\cd{lifted\_d1\_over\_beta}. We call this a ``lifted'' node. Like R,
NIMBLE allows alternative parameterizations, such as the scale or rate
parameterization of the gamma distribution. Choice of parameterization
can generate a lifted node. It's helpful to know why they exist, but you shouldn't need
to worry about them.

Thanks to the plotting capabilities of the \cd{igraph} package that
NIMBLE uses to represent the directed acyclic graph, we can plot the
model  (figure 2.1).

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{plot}\hlstd{(pump}\hlopt{$}\hlstd{graph)}
\end{alltt}
\end{kframe}\begin{figure}
\includegraphics[width=\maxwidth]{figure/plotPump-1} \caption[Directed Acyclic Graph plot of the pump model, thanks to the igraph package]{Directed Acyclic Graph plot of the pump model, thanks to the igraph package}\label{fig:plotPump}
\end{figure}


\end{knitrout}

To simulate from the prior for \cd{theta} (overwriting the initial
values previously in the model) we first need to fully initialize the
model, including any non-stochastic nodes such as lifted nodes.  We do
so using
NIMBLE's \cd{calculate} function and then simulate from the
distribution for \cd{theta}.  First we show how to use the model's
\cd{getDependencies} method to query information about its graph.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,} \hlstr{'beta'}\hlstd{))}
\end{alltt}
\begin{verbatim}
##  [1] "alpha"               "beta"               
##  [3] "lifted_d1_over_beta" "theta[1]"           
##  [5] "theta[2]"            "theta[3]"           
##  [7] "theta[4]"            "theta[5]"           
##  [9] "theta[6]"            "theta[7]"           
## [11] "theta[8]"            "theta[9]"           
## [13] "theta[10]"
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,} \hlstr{'beta'}\hlstd{),} \hlkwc{determOnly} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] "lifted_d1_over_beta"
\end{verbatim}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{0}\hlstd{)} \hlcom{## This makes the simulations here reproducible}
\hlkwd{calculate}\hlstd{(pump, pump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,} \hlstr{'beta'}\hlstd{),} \hlkwc{determOnly} \hlstd{=} \hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlkwd{simulate}\hlstd{(pump,} \hlstr{'theta'}\hlstd{)}
\hlstd{pump}\hlopt{$}\hlstd{theta}   \hlcom{## the new theta values}
\end{alltt}
\begin{verbatim}
##  [1] 1.79180692 0.29592523 0.08369014 0.83617765 1.22254365
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlstd{lambda}  \hlcom{## lambda hasn't been calculated yet}
\end{alltt}
\begin{verbatim}
##  [1]  9.430  1.570  6.290 12.600  0.524  3.140  0.105  0.105
##  [9]  0.210  1.050
\end{verbatim}
\begin{alltt}
\hlkwd{calculate}\hlstd{(pump, pump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'theta'}\hlstd{)))}
\end{alltt}
\begin{verbatim}
## [1] -286.6951
\end{verbatim}
\begin{alltt}
\hlstd{pump}\hlopt{$}\hlstd{lambda}  \hlcom{## now it has}
\end{alltt}
\begin{verbatim}
##  [1] 168.9673926   4.6460261   5.2641096 105.3583839   6.4061287
##  [6]  36.3723548   1.0395209   0.3227420   0.1987001   1.6506161
\end{verbatim}
\end{kframe}
\end{knitrout}

Notice that the first \cd{getDependencies} call returned dependencies
from \cd{alpha} and \cd{beta} down to the next stochastic nodes in the
model.  The second call requested only deterministic dependencies.
We used this as the second argument to \cd{calculate}.  The call to \cd{calculate(pump, `theta')}
expands \cd{`theta'} to include all nodes in \cd{theta}.  After
simulating into \cd{`theta'}, we make sure to calculate its
dependencies so they are kept up to date with the new \cd{theta} values.

\section{Compiling the model}
\label{sec:compiling-model}

Next we compile the model, which means generating C++ code, compiling
that code, and loading it back into R with an object that can be used just
like the uncompiled model. The values in the compiled model will be
initialized from those of the original model in R, but
the original and compiled models are distinct objects so any
subsequent changes in one will not be reflected in the other.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Cpump} \hlkwb{<-} \hlkwd{compileNimble}\hlstd{(pump)}
\hlstd{Cpump}\hlopt{$}\hlstd{theta}
\end{alltt}
\begin{verbatim}
##  [1] 1.79180692 0.29592523 0.08369014 0.83617765 1.22254365
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
\end{verbatim}
\end{kframe}
\end{knitrout}


\section{Creating, compiling and running a basic MCMC specification}

At this point we have initial values for all of the nodes in the model
and we have both the original and compiled versions of the model. As a first algorithm
to try on our model, let's use NIMBLE's default MCMC. Note that conjugate relationships are detected for all nodes except for
\cd{alpha}\footnote{This is because we haven't yet set up NIMBLE to
  detect conjugate relationships involving an exponential
  distribution, but we'll add that one soon.}, on which the default sampler is a random walk Metropolis sampler.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pumpSpec} \hlkwb{<-} \hlkwd{configureMCMC}\hlstd{(pump,} \hlkwc{print} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## [1] RW sampler: alpha,  adaptive: TRUE,  adaptInterval: 200,  scale: 1
## [2] conjugate_dgamma sampler: beta,  dependents_dgamma: theta[1], theta[2], theta[3], theta[4], theta[5], theta[6], theta[7], theta[8], theta[9], theta[10]
## [3] conjugate_dgamma sampler: theta[1],  dependents_dpois: x[1]
## [4] conjugate_dgamma sampler: theta[2],  dependents_dpois: x[2]
## [5] conjugate_dgamma sampler: theta[3],  dependents_dpois: x[3]
## [6] conjugate_dgamma sampler: theta[4],  dependents_dpois: x[4]
## [7] conjugate_dgamma sampler: theta[5],  dependents_dpois: x[5]
## [8] conjugate_dgamma sampler: theta[6],  dependents_dpois: x[6]
## [9] conjugate_dgamma sampler: theta[7],  dependents_dpois: x[7]
## [10] conjugate_dgamma sampler: theta[8],  dependents_dpois: x[8]
## [11] conjugate_dgamma sampler: theta[9],  dependents_dpois: x[9]
## [12] conjugate_dgamma sampler: theta[10],  dependents_dpois: x[10]
\end{verbatim}
\begin{alltt}
\hlstd{pumpSpec}\hlopt{$}\hlkwd{addMonitors}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,} \hlstr{'beta'}\hlstd{,} \hlstr{'theta'}\hlstd{))}
\end{alltt}
\begin{verbatim}
## thin = 1: alpha, beta, theta
\end{verbatim}
\begin{alltt}
\hlstd{pumpMCMC} \hlkwb{<-} \hlkwd{buildMCMC}\hlstd{(pumpSpec)}
\hlstd{CpumpMCMC} \hlkwb{<-} \hlkwd{compileNimble}\hlstd{(pumpMCMC,} \hlkwc{project} \hlstd{= pump)}

\hlstd{niter} \hlkwb{<-} \hlnum{1000}
\hlkwd{set.seed}\hlstd{(}\hlnum{0}\hlstd{)}
\hlstd{CpumpMCMC}\hlopt{$}\hlkwd{run}\hlstd{(niter)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlstd{samples} \hlkwb{<-} \hlkwd{as.matrix}\hlstd{(CpumpMCMC}\hlopt{$}\hlstd{mvSamples)}

\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{),} \hlkwc{mai} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{.5}\hlstd{,} \hlnum{.5}\hlstd{,} \hlnum{.1}\hlstd{,} \hlnum{.2}\hlstd{))}
\hlkwd{plot}\hlstd{(samples[ ,} \hlstr{'alpha'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(alpha))}
\hlkwd{plot}\hlstd{(samples[ ,} \hlstr{'beta'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(beta))}
\hlkwd{plot}\hlstd{(samples[ ,} \hlstr{'alpha'}\hlstd{], samples[ ,} \hlstr{'beta'}\hlstd{],} \hlkwc{xlab} \hlstd{=} \hlkwd{expression}\hlstd{(alpha),}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(beta))}
\hlkwd{plot}\hlstd{(samples[ ,} \hlstr{'theta[1]'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(theta[}\hlnum{1}\hlstd{]))}
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/mcmcPump-1} 
\begin{kframe}\begin{alltt}
\hlkwd{acf}\hlstd{(samples[,} \hlstr{'alpha'}\hlstd{])} \hlcom{## plot autocorrelation of alpha sample}
\hlkwd{acf}\hlstd{(samples[,} \hlstr{'beta'}\hlstd{])}  \hlcom{## plot autocorrelation of beta  sample}
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/mcmcPump-2} 

\end{knitrout}

Notice the posterior correlation between \cd{alpha} and \cd{beta}.
And a measure of the mixing for each is the 
autocorrelation for each, shown by the \cd{acf} plots. 

\section{Customizing the MCMC}
\label{sec:customizing-mcmc}

Let's add an adaptive
block sampler on \cd{alpha} and \cd{beta} jointly and see if that
improves the mixing. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pumpSpec}\hlopt{$}\hlkwd{addSampler}\hlstd{(}\hlkwc{target} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,} \hlstr{'beta'}\hlstd{),} \hlkwc{type} \hlstd{=} \hlstr{'RW_block'}\hlstd{,}
                    \hlkwc{control} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwc{adaptInterval} \hlstd{=} \hlnum{100}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [13] RW_block sampler: alpha, beta,  adaptive: TRUE,  adaptScaleOnly: FALSE,  adaptInterval: 100,  scale: 1,  propCov: identity
\end{verbatim}
\begin{alltt}
\hlstd{pumpMCMC2} \hlkwb{<-} \hlkwd{buildMCMC}\hlstd{(pumpSpec)}

\hlcom{# need to reset the nimbleFunctions in order to add the new MCMC}
\hlstd{CpumpNewMCMC} \hlkwb{<-} \hlkwd{compileNimble}\hlstd{(pumpMCMC2,} \hlkwc{project}  \hlstd{= pump,} \hlkwc{resetFunctions} \hlstd{=} \hlnum{TRUE}\hlstd{)}

\hlkwd{set.seed}\hlstd{(}\hlnum{0}\hlstd{);}
\hlstd{CpumpNewMCMC}\hlopt{$}\hlkwd{run}\hlstd{(niter)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlstd{samplesNew} \hlkwb{<-} \hlkwd{as.matrix}\hlstd{(CpumpNewMCMC}\hlopt{$}\hlstd{mvSamples)}

\hlkwd{par}\hlstd{(}\hlkwc{mfrow} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{4}\hlstd{),} \hlkwc{mai} \hlstd{=} \hlkwd{c}\hlstd{(}\hlnum{.5}\hlstd{,} \hlnum{.5}\hlstd{,} \hlnum{.1}\hlstd{,} \hlnum{.2}\hlstd{))}
\hlkwd{plot}\hlstd{(samplesNew[ ,} \hlstr{'alpha'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(alpha))}
\hlkwd{plot}\hlstd{(samplesNew[ ,} \hlstr{'beta'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(beta))}
\hlkwd{plot}\hlstd{(samplesNew[ ,} \hlstr{'alpha'}\hlstd{], samplesNew[ ,} \hlstr{'beta'}\hlstd{],} \hlkwc{xlab} \hlstd{=} \hlkwd{expression}\hlstd{(alpha),}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(beta))}
\hlkwd{plot}\hlstd{(samplesNew[ ,} \hlstr{'theta[1]'}\hlstd{],} \hlkwc{type} \hlstd{=} \hlstr{'l'}\hlstd{,} \hlkwc{xlab} \hlstd{=} \hlstr{'iteration'}\hlstd{,}
     \hlkwc{ylab} \hlstd{=} \hlkwd{expression}\hlstd{(theta[}\hlnum{1}\hlstd{]))}
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/mcmcPump2-1} 
\begin{kframe}\begin{alltt}
\hlkwd{acf}\hlstd{(samplesNew[,} \hlstr{'alpha'}\hlstd{])} \hlcom{## plot autocorrelation of alpha sample}
\hlkwd{acf}\hlstd{(samplesNew[,} \hlstr{'beta'}\hlstd{])}  \hlcom{## plot autocorrelation of beta  sample}
\end{alltt}
\end{kframe}
\includegraphics[width=\maxwidth]{figure/mcmcPump2-2} 

\end{knitrout}

We can see that the block sampler has decreased the 
autocorrelation for both \cd{alpha} and \cd{beta}.  Of course these
are just short runs.

Once you learn the MCMC system, you can write your own samplers and
include them.  The entire system is written in nimbleFunctions.

\section{Running MCEM}
\label{sec:running-mcem}

NIMBLE is a system for working with algorithms, not just an MCMC engine. So let's try maximizing the marginal likelihood for \cd{alpha} and \cd{beta} using Monte Carlo Expectation Maximization\footnote{Note that for this model, one could analytically integrate over \cd{theta} and then numerically maximize the resulting marginal likelihood.}. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{pump2} \hlkwb{<-} \hlstd{pump}\hlopt{$}\hlkwd{newModel}\hlstd{()}

\hlstd{nodes} \hlkwb{<-} \hlstd{pump2}\hlopt{$}\hlkwd{getNodeNames}\hlstd{(}\hlkwc{stochOnly} \hlstd{=} \hlnum{TRUE}\hlstd{)}

\hlstd{box} \hlkwb{=} \hlkwd{list}\hlstd{(} \hlkwd{list}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,}\hlstr{'beta'}\hlstd{),} \hlkwd{c}\hlstd{(}\hlnum{0}\hlstd{,} \hlnum{Inf}\hlstd{)))}

\hlstd{pumpMCEM} \hlkwb{<-} \hlkwd{buildMCEM}\hlstd{(}\hlkwc{model} \hlstd{= pump2,} \hlkwc{latentNodes} \hlstd{=} \hlstr{'theta[1:10]'}\hlstd{,}
                       \hlkwc{boxConstraints} \hlstd{= box)}

\hlstd{pumpMLE} \hlkwb{<-} \hlkwd{pumpMCEM}\hlstd{()}
\hlcom{# Note: buildMCEM returns an R function that contains a}
\hlcom{# nimbleFunction rather than a nimble function. That is why}
\hlcom{# pumpMCEM() is used instead of pumpMCEM$run().}

\hlstd{pumpMLE}
\end{alltt}
\begin{verbatim}
##     alpha      beta 
## 0.8230659 1.2600147
\end{verbatim}
\end{kframe}
\end{knitrout}

Both estimates are within 0.01 of the values reported by George et
al. (1993)\footnote{George, E.I., Makov, U.E. \& Smith,
  A.F.M. 1993. Conjugate likelihood
  distributions. \textit{Scand. J. Statist.} \textbf{20}:147-156.
  Their numbers were accidentally swapped in Table 2.}

\section{Creating your own functions}
\label{sec:creating-your-own}



Now let's see an example of writing our own algorithm and using it on
the model. We'll do something simple: simulating multiple values for a
designated set of nodes and calculating every part of the model that
depends on them.

Here is our \cd{nimbleFunction}:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{simNodesMany} \hlkwb{<-} \hlkwd{nimbleFunction}\hlstd{(}
    \hlkwc{setup} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{model}\hlstd{,} \hlkwc{nodes}\hlstd{) \{}
        \hlstd{mv} \hlkwb{<-} \hlkwd{modelValues}\hlstd{(model)}
        \hlstd{deps} \hlkwb{<-} \hlstd{model}\hlopt{$}\hlkwd{getDependencies}\hlstd{(nodes)}
        \hlstd{allNodes} \hlkwb{<-} \hlstd{model}\hlopt{$}\hlkwd{getNodeNames}\hlstd{()}
    \hlstd{\},}
    \hlkwc{run} \hlstd{=} \hlkwa{function}\hlstd{(}\hlkwc{n} \hlstd{=} \hlkwd{integer}\hlstd{()) \{}
        \hlkwd{resize}\hlstd{(mv, n)}
        \hlkwa{for}\hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{n) \{}
            \hlkwd{simulate}\hlstd{(model, nodes)}
            \hlkwd{calculate}\hlstd{(model, deps)}
            \hlkwd{copy}\hlstd{(}\hlkwc{from} \hlstd{= model,} \hlkwc{nodes} \hlstd{= allNodes,} \hlkwc{to} \hlstd{= mv,} \hlkwc{rowTo} \hlstd{= i,} \hlkwc{logProb} \hlstd{=} \hlnum{TRUE}\hlstd{)}
        \hlstd{\}}
    \hlstd{\})}

\hlstd{simNodesTheta1to5} \hlkwb{<-} \hlkwd{simNodesMany}\hlstd{(pump,} \hlstr{'theta[1:5]'}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Here are a few things to notice about the \cd{nimbleFunction}
\begin{enumerate}
\item The setup code is written in R.  It creates relevant
information specific to our model for use in the run-time code.  
\item The run-time is written in NIMBLE.  It carries out the
  calculations using the information determined once for each set of
  \cd{model} and \cd{nodes} arguments by the setup
  code. The run-time code is what will be compiled.
\item A \cd{modelValues} object is created to hold multiple sets of
  values for variables
  in the model provided.
\item The NIMBLE code requires type information about the argument
  \cd{n}.  In this case it is a scalar integer.  
\item The for-loop looks just like R, but only sequential integer
  iteration is allowed.
\item The functions \cd{calculate} and \cd{simulate}, which were
  introduced above in R, can be used in NIMBLE.
\item The special function \cd{copy} is used here to record values
  from the model into the modelValues object.  
\item One instance, or ``specialization'', \cd{simNodesTheta1to5}, has
  been made by calling \cd{simNodesMany} with the \cd{pump} model and
  nodes \cd{`theta[1:5]'} as arguments.  These are used as inputs to
  the setup function.  What is returned is an object of a uniquely
  generated reference class with a \cd{run} method (member function)
  that will execute the \cd{run} code.
\end{enumerate}

In fact, \cd{simNodesMany} is very similar to a standard
\cd{nimbleFunction} provided with nimble, \cd{simNodesMV}.

Now let's execute this \cd{nimbleFunction} in R, before compiling it.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{0}\hlstd{)}  \hlcom{## make the calculation repeatable}
\hlstd{pump}\hlopt{$}\hlstd{alpha} \hlkwb{<-} \hlstd{pumpMLE[}\hlnum{1}\hlstd{]}
\hlstd{pump}\hlopt{$}\hlstd{beta} \hlkwb{<-} \hlstd{pumpMLE[}\hlnum{2}\hlstd{]}
\hlkwd{calculate}\hlstd{(pump, pump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,}\hlstr{'beta'}\hlstd{),} \hlkwc{determOnly} \hlstd{=} \hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{saveTheta} \hlkwb{<-} \hlstd{pump}\hlopt{$}\hlstd{theta}
\hlstd{simNodesTheta1to5}\hlopt{$}\hlkwd{run}\hlstd{(}\hlnum{10}\hlstd{)}
\hlstd{simNodesTheta1to5}\hlopt{$}\hlstd{mv[[}\hlstr{'theta'}\hlstd{]][}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [[1]]
##  [1] 1.43717729 1.53093576 1.45028779 0.03716752 0.13310071
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
## 
## [[2]]
##  [1] 0.34222406 3.45822771 0.82805042 0.08796383 0.34440151
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
\end{verbatim}
\begin{alltt}
\hlstd{simNodesTheta1to5}\hlopt{$}\hlstd{mv[[}\hlstr{'logProb_x'}\hlstd{]][}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [[1]]
##  [1] -115.767499  -20.856152  -73.444053   -8.258863   -3.570190
##  [6]   -7.429868   -1.000761   -1.453644   -9.840589  -39.096527
## 
## [[2]]
##  [1] -19.688263 -50.299758 -37.107538  -2.598331  -1.825300
##  [6]  -7.429868  -1.000761  -1.453644  -9.840589 -39.096527
\end{verbatim}
\end{kframe}
\end{knitrout}

In this code we have initialized the values of \cd{alpha}, \cd{beta},
to their MLE, and recorded the \cd{theta} values to use next.  Then we
have requested 10 simulations from
\cd{simNodesTheta1to5}.  Shown are the first two simulation results
for \cd{theta} and the log probabilities of \cd{x}.  Notice that
\cd{theta[6:10]} and the corresponding log probabilities for \cd{x[6:10]} are unchanged because the nodes being simulated are only
\cd{theta[1:5]}.  In R, this function runs slowly.

Finally, let's compile the function and run that version.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{CsimNodesTheta1to5} \hlkwb{<-} \hlkwd{compileNimble}\hlstd{(simNodesTheta1to5,}
                                    \hlkwc{project}  \hlstd{= pump,} \hlkwc{resetFunctions} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{Cpump}\hlopt{$}\hlstd{alpha} \hlkwb{<-} \hlstd{pumpMLE[}\hlnum{1}\hlstd{]}
\hlstd{Cpump}\hlopt{$}\hlstd{beta} \hlkwb{<-} \hlstd{pumpMLE[}\hlnum{2}\hlstd{]}
\hlkwd{calculate}\hlstd{(Cpump, Cpump}\hlopt{$}\hlkwd{getDependencies}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{'alpha'}\hlstd{,}\hlstr{'beta'}\hlstd{),} \hlkwc{determOnly} \hlstd{=} \hlnum{TRUE}\hlstd{))}
\end{alltt}
\begin{verbatim}
## [1] 0
\end{verbatim}
\begin{alltt}
\hlstd{Cpump}\hlopt{$}\hlstd{theta} \hlkwb{<-} \hlstd{saveTheta}

\hlkwd{set.seed}\hlstd{(}\hlnum{0}\hlstd{)}
\hlstd{CsimNodesTheta1to5}\hlopt{$}\hlkwd{run}\hlstd{(}\hlnum{10}\hlstd{)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\begin{alltt}
\hlstd{CsimNodesTheta1to5}\hlopt{$}\hlstd{mv[[}\hlstr{'theta'}\hlstd{]][}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [[1]]
##  [1] 1.43717729 1.53093576 1.45028779 0.03716752 0.13310071
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
## 
## [[2]]
##  [1] 0.34222406 3.45822771 0.82805042 0.08796383 0.34440151
##  [6] 1.15835525 0.99001994 0.30737332 0.09461909 0.15720154
\end{verbatim}
\begin{alltt}
\hlstd{CsimNodesTheta1to5}\hlopt{$}\hlstd{mv[[}\hlstr{'logProb_x'}\hlstd{]][}\hlnum{1}\hlopt{:}\hlnum{2}\hlstd{]}
\end{alltt}
\begin{verbatim}
## [[1]]
##  [1] -115.767499  -20.856152  -73.444053   -8.258863   -3.570190
##  [6]   -2.593423   -1.006239   -1.180023   -1.757379   -2.531520
## 
## [[2]]
##  [1] -19.688263 -50.299758 -37.107538  -2.598331  -1.825300
##  [6]  -2.593423  -1.006239  -1.180023  -1.757379  -2.531520
\end{verbatim}
\end{kframe}
\end{knitrout}

Given the same initial values and the same random number generator
seed, we got identical results, but it happened much faster.


%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr



\chapter{More Introduction}

Now that we have shown a brief example, we will introduce more about
the concepts and design of NIMBLE.  Subsequent chapters will go into
more detail about working with models and programming in NIMBLE.  

One of the most important concepts behind NIMBLE is to allow a
combination of high-level processing in R and low-level processing in
compiled C++.  For example, when we write a Metropolis-Hastings MCMC
sampler in the NIMBLE language, the inspection of the model structure
related to one node is done in R, and the actual sampler calculations
are done in compiled C++.  The theme of separating one-time high-level
processing and repeated low-level processing will become clearer as we
introduce more about NIMBLE's components.


\section{NIMBLE adopts and extends the BUGS language for specifying models}

We adopted the BUGS language, and we have extended it to make it more
flexible. The BUGS language originally appeared in WinBUGS, then in
OpenBUGS and JAGS.  These systems all provide automatically-generated
MCMC algorithms, but we have adopted only the language for describing
models, not their systems for generating MCMCs. In fact, if you want
to use those or other MCMCs in combination with NIMBLE's other algorithms,
you can\footnote{and will be able to do so more thoroughly in the future}.  We adopted BUGS
because it has been so successful, with over 30,000 registered users
by the time they stopped counting, and
with many papers and books that provide BUGS code as a way to document
their statistical models. To learn the basics of BUGS, we refer you to
the OpenBUGS or JAGS web sites.  For the most part, if you have BUGS code, you can try
NIMBLE.

  NIMBLE takes BUGS code and does several things with it:
  \begin{enumerate}
  \item NIMBLE extracts all the declarations in the BUGS code to
    create a \nm{model definition}.  This includes a directed acyclic graph (DAG)
    representing the model and functions that can 
    inspect the graph and model relationships.  Usually you'll ignore the \nm{model definition}
    and let NIMBLE's default options take you directly to the next step.
  \item From the \nm{model definition}, NIMBLE builds a working model
    in R.  This can be used to manipulate variables and operate the
    model from R.  Operating the model includes calculating,
    simulating, or querying the log probability value of model
    nodes. These basic capabilities, along with the tools to query model
    structure, allow one to write programs that use the model and
    adapt to its structure.
  \item From the working model, NIMBLE generates customized C++ code
    representing the model, compiles the C++, loads it back into R,
    and provides an R object that interfaces to it.  We often call the
    uncompiled model the ``R-model'' and the compiled model the
    ``C-model.''  The C-model can be used identically to the R-model,
    so code written to use one will work with the other.  We use the
    word ``compile'' to refer to
    the entire process of generating C++ code, compiling it and
    loading it into R.
  \end{enumerate}
 
  More about specifying and manipulating models is in Chapter \ref{cha:building-models}-\ref{cha:using-bugs-models}.
  
  
  \section{The NIMBLE language for writing algorithms}
  \label{sec:nimble-lang-writ}
  
  NIMBLE provides a language, embedded within and similar in style to
  R, for writing algorithms that can operate on BUGS models.  The
  algorithms can use NIMBLE's utilities for inspecting the structure
  of a model, such as determining the dependencies between variables.
  And the algorithms can control the model, changing values of its
  variables and controlling execution of its probability calculations
  or corresponding simulations.  Finally, the algorithms can use
  automatically generated data structures to manage sets of model
  values and probabilities.  In fact, the calculations of the model
  are themselves constructed as functions in the NIMBLE language, as
  are the algorithms provided in NIMBLE's algorithm library.  This
  means that you can BUGS with new
  distributions and new functions written in NIMBLE.
  
  Like the models themselves, functions in
  the NIMBLE language are turned into C++, which is compiled, loaded,
  and interfaced to R.  

Programming in NIMBLE involves a fundamental distinction between:
\begin{enumerate}
\item the steps for an algorithm that need to happen only
once, at the beginning, such as inspecting the model; and
\item the steps that need to happen each time a function is called, such as MCMC iterations.
\end{enumerate}
Programming in NIMBLE allows, and indeed requires, these steps to be
given separately.  When one writes a \cd{nimbleFunction}, each of
these parts can be provided.  The former, if needed, are given in a \nm{setup
  function}, and they are executed directly in R, allowing any feature
of R to be used.  The latter are in one or more \nm{run-time functions}, and they
are turned into C++.  Run-time code is written in the NIMBLE language,
which you can think of as a carefully controlled, small subset of R
along with some special functions for handling models and NIMBLE's
data structures.

What NIMBLE does with a \cd{nimbleFunction} is similar to what it does
with a BUGS model:
\begin{enumerate}
\item NIMBLE creates a working R version of the \cd{nimbleFunction},
  which you can use with an R-model or a C-model.
\item NIMBLE generates C++ code for the run-time function(s), compiles
  it, and loads it back into R with an interface nearly identical to
  the R version of the \cd{nimbleFunction}.   As for models, we refer
  to the uncompiled and compiled versions as R-nimbleFunctions and
  C-nimbleFunctions, respectively.   In v\ver, the behavior
  of \cd{nimbleFunction}s is usually very similar, but not identical,
  between the two versions.
\end{enumerate}

  More about writing algorithms is in Chapter \ref{cha:progr-with-models}.
  
\section{The NIMBLE algorithm library}
\label{sec:nimble-algor-libr}

In v\ver, the NIMBLE algorithm library is fairly limited.  It includes:

\begin{enumerate}
\item MCMC with samplers including conjugate, slice, adaptive random
  walk, and adaptive block.  NIMBLE's MCMC system illustrates the
  flexibility of combining R and C++.  An R function inspects the
  model object and creates an MCMC specification object representing
  choices of which kind of sampler to use for each node.  This MCMC
  specification can be modified in R, such as adding new samplers for
  particular nodes, before compiling the algorithm.  Since
  each sampler is written in NIMBLE, you can use its source code or
  write new samplers to insert into the MCMC.  And if you want to
  build an entire MCMC system differently, you could do that too.
\item A \cd{nimbleFunction} that provides a likelihood function for
  arbitrary sets of nodes in any model. This can be useful for simple
  maximum likelihood estimation of non-hierarchical models using R's
  optimization functions.  And it can be useful for other R packages
  that run algorithms on any likelihood function.
\item A \cd{nimbleFunction} that provides ability to simulate,
  calculate, or retrieve the summed log probability (density) of many
 sets of values for
  arbitrary sets of nodes.
\item A basic Monte Carlo Expectation Maximization (MCEM) algorithm.
  MCEM has its issues as an algorithm, such as potentially slow convergence to maximum
  likelihood (i.e. empirical Bayes in this context) estimates, but we chose it as a
  good illustration of how NIMBLE can be used.  Each MCMC step uses
  NIMBLE's MCMC; the objective function for maximization is another
  \cd{nimbleFunction}; and the actual maximization is done through R's
  \cd{optim} function\footnote{In the future we plan to provide direct
    access to R's optimizers from within \cd{nimbleFunction}s}.
\end{enumerate}
  
More about the NIMBLE algorithm library is in Chapter \ref{cha:algos-provided}.

\end{document}
