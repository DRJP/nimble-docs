<<chunk0, echo = FALSE>>=
## source the code
if(!require(nimble, warn.conflicts = FALSE, quietly = TRUE)) {
#source(file.path('..', '..', 'examples', 'demos', 'loadAllCode.R'))
}
require(methods, warn.conflicts = FALSE, quietly = TRUE)  # seems to be needed, but why?
require(igraph, warn.conflicts = FALSE, quietly = TRUE)  # same question
@ 

Creation and execution of an MCMC algorithm in NIMBLE consists of several independent steps:
\begin{itemize}
\item Creating a specification for the MCMC algorithm for a specific model
\item Building and compiling an executable MCMC function from the specification
\item Running the MCMC function
\item Extracting and analyzing the posterior samples
\end{itemize}

We'll also discuss:

\begin{itemize}
\item Sampling algorithms provided with the NIMBLE package
\item A detailed example of using MCMC
\item Higher level usage: MCMC Suite
\item Advanced Topics
\end{itemize}

\section{The MCMC specification}

The MCMC specification contains the necessary information to fully specify an MCMC algorithm.  This includes:

\begin{itemize}
    \item The model on which the MCMC will operate
    \item The model nodes which will be sampled (updated) during execution of the MCMC
    \item The particular sampling algorithms for each of these nodes, including any control parameters required by each sampling algorithm
    \item The variables which will be monitored (recorded) during execution of the MCMC
    \item The thinning interval on which the monitored nodes will be recorded
\end{itemize}

An MCMC specification is created using \cd{configureMCMC()}, and the resulting MCMC specification object will generally be denoted as \cd{mcmcspec} in this Chapter.  The only required argument to \cd{configureMCMC()} is the original model object, which is the object resulting from a call to \cd{nimbleModel()}.

We've already seen a basic example of an MCMC in the introductory example in Section \ref{sec:brief-example}.

\subsection{Default MCMC specification}
\label{sec:default-mcmc-spec}

Assuming we have a model named \cd{Rmodel}, the following will generate a default MCMC specification:
<<mcmcspec, eval=FALSE>>=
mcmcspec <- configureMCMC(Rmodel)
@

The default specification will contain a single sampler for each \emph{stochastic, non-data} node in the model, and the samplers will be ordered by the topological dependencies of the model.

\cd{configureMCMC()} creates an \nm{MCMCspec} reference class object. The \nm{MCMCspec} reference class has a number of methods, such as \cd{addSampler()} that will be described in this Chapter.

An MCMC function corresponding to the default MCMC specification for \cd{model} may also be created directly using the call \cd{buildMCMC(model)}; see section \ref{sec:build-compile-mcmc} for more information.

\subsubsection{Default assignment of sampler algorithms}

The particular sampling algorithm assigned to each stochastic node is determined by the following, in order of precedence:

\begin{enumerate}
\item If the node has no stochastic dependents, a predictive \nm{end} sampler is assigned.  The \nm{end} sampling algorithm merely calls \cd{simulate()} on the particular node, since this simulates identically from the conditional posterior distribution.
\item The node is checked for presence of a conjugate relationship between its prior distribution and the distributions of its stochastic dependents.  If it is determined to be in a conjugate relationship, then the corresponding \nm{conjugate} sampler is assigned.
\item If the node is discrete-valued, then a \nm{slice} sampler is assigned.
\item If the node is vectorized (specified using a multivariate distribution), then a single \nm{RW\_block} sampler is assigned to jointly sample all scalar components of the multivariate node.  This sampler performs multi-dimensional Metropolis-Hastings random walk sampling.
\item If none of the above criteria are satisfied, then the default, scalar random walk \nm{RW} sampler is assigned.  This algorithm performs Metropolis-Hastings sampling with a normal proposal distribution.
\end{enumerate}

The control parameters governing each of the default sampling algorithms are dictated by the system-level variable \cd{controlDefaultList}.  These default values are described in Section \ref{sec:samplers-provided}, along with the related sampling algorithms.

\subsubsection{Additional control arguments}

The following optional control arguments to \cd{configureMCMC()} may be used to override the default assignment of sampler algorithms:

\begin{description}
\item[useConjugacy (default \cd{TRUE})] If \cd{TRUE}, conjugate samplers will be assigned to nodes determined to be in conjugate relationships.  If \cd{FALSE}, no conjugate samplers will be assigned.
\item[onlyRW (default \cd{FALSE})]  If \cd{TRUE}, \cd{RW} samplers will be assigned to all non-terminal, continuous-valued stochastic nodes.  Terminal stochastic nodes are still assigned \cd{end} samplers.
\item[onlySlice (default \cd{FALSE})]  If \cd{TRUE}, \cd{slice} samplers will be assigned to all non-terminal stochastic nodes.  Terminal stochastic nodes are still assigned \nm{end} samplers.
\item[multivariateNodesAsScalars (default \cd{FALSE})]  If \cd{TRUE}, then independent scalar random walk Metropolis-Hastings samplers (\cd{RW}) will be assigned to all scalar components comprising multivariate nodes.  This contrasts the default behavior of a single block sampler being assigned to multivariate nodes.  Regardless of the value of this argument, conjugate samplers will be assigned to conjugate (scalar and multivariate nodes), provided \cd{useConjugacy = TRUE}.
\end{description}

% I think we can leave the following out as I don't see much content in it - CJP
% Any of the aforementioned control arguments may be used as in the context:
<<mcmcspec2, eval=FALSE, echo=FALSE>>=
mcmcspec <- configureMCMC(Rmodel, onlyRW = TRUE)
@

\subsubsection{Default monitors}

The default MCMC specification includes monitors on all top-level stochastic nodes of the model.



\subsection{Customizing the MCMC specification}

The MCMC specification may be customized in a variety of ways, either through additional named arguments to \cd{configureMCMC()} or by calling member methods of an existing \cd{MCMCspec} object.

\subsubsection{Default samplers for particular nodes}

One can create an MCMC specification with default samplers on just a particular set of nodes using the \cd{nodes} argument to \cd{configureMCMC()}. The value for the \cd{nodes} argument may be a character vector, containing particular node names, or variable names.  In the case of a variable name, a default sampler will be added for all stochastic nodes contained within this particular variable.  The choice of the particular sampling algorithm assigned to node follows the same order of precedence described in Section \ref{sec:default-mcmc-spec}.

If the \cd{nodes} argument is provided, default samplers are created only for the \emph{stochastic} nodes specified by this argument (possibly including data nodes), and the ordering of these sampling algorithms respects the ordering within the \cd{nodes} argument.  It is worthwhile to note this is the \emph{only} way in which a sampler may be placed on a data node, which upon execution of the MCMC will overwrite any value stored in the data node.

The \cd{nodes} argument may also be provided with the value \cd{NULL}, \cd{character(0)}, or \cd{list()}, any of which will result in an MCMC specification containing no samplers.

\subsubsection{Overriding the default sampler control list values}
The default values of control list elements for all sampling algorithms may be overridden through use of the \cd{control} argument to \cd{configureMCMC()}, which should be a named list. 
Named elements in the \cd{control} argument will be used for all default samplers added.  In addition, they are retained in the \cd{MCMCspec} object, and will be used as defaults for any subsequent samplers added to this same \cd{MCMCspec} object.  For example, the following will create the default MCMC specification, except all \cd{RW} samplers will have their initial \cd{scale} set to 3, and none of the samplers (\nm{RW}, or otherwise) will be adaptive.

<<mcmcspec6, eval=FALSE>>=
mcmcspec <- configureMCMC(Rmodel, control = list(scale = 3, adaptive = FALSE))
@


\subsubsection{Subsequent addition of samplers for particular nodes}

Once an \cd{MCMCspec} object has been created, additional samplers may be added to the specification, by calling the \cd{addSampler} method on the \cd{MCMCspec} object. The mandatory \cd{type} argument is a character string, specifying the type of sampler to be added.  For example, \cd{type = `RW'} specifies the Metropolis-Hastings random walk sampler, and \cd{type = `slice'} specifies a slice sampler.

The \cd{type} argument must specify a valid sampling algorithm, which has been generated as the result of \cd{nimbleFunction()}.  If \cd{type = `typeStr'} is specified, then the sampling function \cd{sampler\_typeStr} must exist.  If it does not exist, an error will result.

The optional \cd{control} argument may be used to provide a list of additional control list elements for the sampler.  When the \cd{control} argument is provided in a call to \cd{addSampler()}, the \cd{control} list elements specified will have the highest priority.  The hierarchy of precedence for control list elements for samplers is:

\begin{enumerate}
\item Those supplied in the \cd{control} list argument to \cd{addSampler()}
\item Those supplied in the \cd{control} list argument in the preceding preceding call to \cd{configureMCMC()}
\item Those in the system-level \cd{controlDefaultList} variable
\end{enumerate}

Note that every sampling algorithm will require either the \cd{targetNode} element of the \cd{control} list, or the \cd{targetNodes} element in the case of multivariate samplers.  There is no default value for the \cd{targetNode} element, since it reflects a property of the particular sampler, rather than the sampling algorithm.

A call to \cd{addSampler()} results in a single instance of the specified sampler being added at end of the current sampler ordering.

\subsubsection{Printing, re-ordering, and removing samplers}

The current, ordered, list of all samplers in the MCMC specification may be printed by calling the \cd{getSamplers()} method. Each sampler is displayed, along with the value of all control parameters, and the index corresponding to its position in the sampler ordering.  These indices are useful for removing and re-ordering the samplers.

The existing samplers may be re-ordered using the \cd{setSamplers()} method. The \cd{ind} argument is a vector of sampler indices.  The samplers in the MCMC specification will be replaced by the samplers corresponding to the indices provided.  A few examples of how this may operate (all examples assume the \cd{MCMCspec} object initially contains 10 samplers; each example call is independent of the others) are as follows:
<<setSamplers2, eval=FALSE>>=
## Truncate the current list of samplers to the first 5
mcmcspec$setSamplers(ind = 1:5)

## Retain only the third sampler, which will subsequently 
## become the first sampler
mcmcspec$setSamplers(ind = 3)

## Reverse the ordering of the samplers
mcmcspec$setSamplers(ind = 10:1)

## The new set of samplers becomes the 
## {first, first, first, second, third} from the current list.
## Upon each iteration of the MCMC, the 'first' sampler will 
## be executed 3 times, however each instance of the sampler 
## will be independent in terms of scale, adaptation, etc.
mcmcspec$setSamplers(ind = c(1, 1, 1, 2, 3))
@

Samplers may be removed from the current sampler ordering through use of the \cd{removeSamplers()} method.  The following examples demonstrate this usage, where again each example assumes that \cd{mcmcspec} initially contains 10 samplers, and each example is independent of the others:
<<removeSamplers, eval=FALSE>>=
## Remove the first sampler
mcmcspec$removeSamplers(ind = 1)

## Remove the last five samplers
mcmcspec$removeSamplers(ind = 6:10)

## Remove all samplers,
## resulting in an empty MCMC specification, containing no samplers
mcmcspec$removeSamplers(ind = 1:10)

## Special case: providing no argument removes all samplers
mcmcspec$removeSamplers()
@

\subsubsection{Monitors and thinning intervals}

An \cd{MCMCspec} object contains two independent lists of variables to monitor, which correspond to two independent thinning intervals: \cd{thin} corresponding to \cd{monitors}, and \cd{thin2} corresponding to \cd{monitors2}.  Monitors operate at the \textit{variable} level.  Only entire model variables may be monitored.  Specifying a monitor on a \textit{node}, e.g., \cd{x[1]}, will result in the entire variable \cd{x} being monitored.

The variables specified in \cd{monitors} will be recorded (with thinning interval \cd{thin}) into the \nm{modelValues} object \cd{mvSamples}, which is a member data object of the MCMC algorithm object.  Likewise, the variables specified in \cd{monitors2} will be recorded (with thinning interval \cd{thin2}) into the \nm{modelValues} object \cd{mvSamples2}.  See Section \ref{sec:extracting-samples} for information about extracting these \nm{modelValues} objects from the MCMC algorithm object.

Monitors may be added to the MCMC specification either in the original call to \cd{configureMCMC()} or using the \cd{addMonitors()} method:
<<addMonitors, eval=FALSE>>=
## Using an arguments to configureMCMC()
mcmcspec <- configureMCMC(Rmodel, monitors = c('alpha', 'beta'), monitors2 = 'x')

## Calling a member method of the mcmcspec object
## This results in the same monitors as above
mcmcspec$addMonitors(c('alpha', 'beta'))
mcmcspec$addMonitors2('x')
@

Similarly, either thinning interval may be set analogously:
<<thinning, eval=FALSE>>=
## Using an argument to configureMCMC()
mcmcspec <- configureMCMC(Rmodel, thin = 1, thin2 = 100)

## Calling a member method of the mcmcspec object
## This results in the same thinning intervals as above
mcmcspec$setThin(1)
mcmcspec$setThin2(100)
@

The current lists of monitors, and thinning intervals, may be displayed using the \cd{getMonitors()} method.  Both sets of monitors (\cd{monitors} and \cd{monitors2}) may be reset to empty character vectors by calling the \cd{resetMonitors()} method.

The preceding examples can be used to motivate the practical usage of the \textit{two} separate monitor lists and thinning intervals.  Consider the circumstance where \cd{alpha} and \cd{beta} are scalar model variables of interest, hence we wish to record all samples, which is possible without using much computer memory or, ultimately, disk storage.  The \cd{x} variable might represent a latent matrix of non-trivial dimensions, for which we desire a sparsely thinned record of samples, so as to limit memory or disk requirements.

\section{Building and compiling the MCMC algorithm}
\label{sec:build-compile-mcmc}

Once the MCMC specification object has been created, and customized to one's liking, it may be used to build an executable MCMC function.  The following call uses the specification \cd{mcmcspec} to build an instance of the MCMC function for the model:

<<buildMCMC, eval=FALSE>>=
Rmcmc <- buildMCMC(mcmcspec)
@

The \cd{buildMCMC()} function accepts only a single argument, which may be an MCMC specification object created from a call to \cd{configureMCMC()}.  The resulting MCMC function, \cd{Rmcmc}, is an instance of a NIMBLE function specific to the model on which the specification was based.

The \cd{buildMCMC()} function is overloaded to accept NIMBLE model object as its argument.  In this case, it creates an MCMC function specified by the default MCMC specification (section \ref{sec:default-mcmc-spec}) for the model.  The following two MCMC functions will be identical:

<<overloadedBuildMCMC, eval=FALSE>>=
mcmcspec <- configureMCMC(Rmodel)   ## default MCMC specification
Rmcmc1 <- buildMCMC(mcmcspec)

Rmcmc2 <- buildMCMC(Rmodel)   ## uses the default specification for Rmodel
@

For speed of execution, we usually desire to compile the MCMC function to C++ (as is the case for other NIMBLE functions).  To do so, we use \cd{compileNimble()}.  Care must be taken to perform this compilation in the same project that contains the underlying model and compiled model objects.  A typical compilation call looks like:

<<compileMCMC, eval=FALSE>>=
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
@

Alternatively, if the model has not already been compiled, they can be compiled together in one line:

<<compileMCMC2, eval=FALSE>>=
Cmcmc <- compileNimble(Rmodel, Rmcmc)
@


\section{Executing the MCMC algorithm}

The MCMC function (either the compiled or uncompiled version) has one required argument, \cd{niter}, representing the number of iterations to run the MCMC algorithm.  We'll assume the function is called \cd{mcmc}. Calling \cd{mcmc(niter)} causes the full list of samplers (as determined from the input \cd{MCMCspec} object) to be executed \cd{niter} times, and the monitored variables to stored into the internal \nm{modelValues} objects as governed by the corresponding thinning intervals.

The \cd{mcmc()} function has an optional \cd{reset} argument.  When \cd{reset = TRUE} (the default value), the following occurs at the onset of the call to \cd{mcmc\$run()}:
\begin{itemize}
\item All model nodes are checked that they contain values, and that model log-probabilities are up-to-date with the current node values.  If a stochastic node is missing a value, it is populated using a call to \cd{simulate()}.  The values of deterministic nodes are calculated, to be consistent with their parent nodes.  If any right-hand-side-only nodes are missing a value, an error results.
\item All MCMC sampler functions are reset to their initial state: the initial values of any sampler control parameters (e.g., \cd{scale}, \cd{sliceWidth}, or \cd{propCov}) are reset to their initial values, as were specified by the original MCMC specification.
\item The internal \nm{modelValues} objects \cd{mvSamples} and \cd{mvSamples2} are each resized to the appropriate length, for holding the required number of samples (\cd{niter/thin}, and \cd{niter/thin2}, respectively).
\end{itemize}

The aforementioned actions have the effect of ``resetting'' the entire MCMC algorithm to its initial state.  This (default) functionality may be thought of as initializing separate, independent chains of the same MCMC algorithm.

When \cd{mcmc\$run(niter, reset = FALSE)} is called, the MCMC algorithm effectively picks up from where it left off.  No values in the model are checked or altered, and sampler functions are not reset to their initial states.  Further, the internal \nm{modelValues} objects containing samples are each \textit{increased in size to appropriately accommodate the additional samples}.  This functionality may be used when the MCMC algorithm has already been run for some number of iterations, and one wishes to continue running the MCMC, exactly from where it left off, for some additional number of iterations.

The MCMC function has a second optional argument, \cd{simulateAll}, with default value \cd{FALSE}.  When \cd{mcmc(niter, simulateAll = TRUE)} is called, the \cd{simulate()} method of all stochastic nodes in the model is called, prior to beginning MCMC iterations.  This behavior may be thought of as generating a new set of random, initial values for all stochastic nodes in the model. Note that there is some danger in doing this when non-informative priors (such as normal distributions with very large variances or gamma distributions with small parameter values) are used for top-level nodes, as one may easily simulate an extreme value as the starting value for a given node.

\section{Extracting MCMC samples}
\label{sec:extracting-samples}

Samples may be extracted in the form of \nm{modelValues} objects, from either the uncompiled or compiled MCMC functions.  Note that the \nm{modelValues} extracted from an uncompiled MCMC function will be an uncompiled \nm{modelValues} object, while that extracted from the compiled MCMC function will be a compiled \nm{modelValues} object.  In either case, the \nm{modelValues} object corresponding to \cd{monitors} and \cd{thin} will be named \cd{mvSamples}, and that corresponding to the \cd{monitors2} and \cd{thin2} will be named \cd{mvSamples2}.  These objects may be extracted from either \cd{mcmc()} function as:

<<samples, eval=FALSE>>=
mvSamples <- mcmc$mvSamples
mvSamples2 <- mcmc$mvSamples2
@

Subsequently, these \nm{modelValues} objects may be transformed into a more convenient matrix object, using the \cd{as.matrix()} method for \nm{modelValues} objects:

<<as.matrix-samples, eval=FALSE>>=
samplesMatrix <- as.matrix(mvSamples)
samplesMatrix2 <- as.matrix(mvSamples2)
@

The resulting \cd{samplesMatrix} matrix objects will have the \textit{node names} of the monitored nodes as the column names.  Thus, for example, the mean of the samples for node \cd{x} could be calculated as:

<<access-samples, eval=FALSE>>=
mean(samplesMatrix[, 'x'])
@

\section{Sampler Algorithms provided with NIMBLE}
\label{sec:samplers-provided}

The NIMBLE package provides a variety of sampling algorithms available for use.  Any of the following samplers may be added to an MCMC specification, using the \cd{addSampler()}.  Additional sampler functions may also be written using the NIMBLE language, as discussed in Chapter \ref{cha:progr-with-models}.

We now describe the samplers which are provided with the NIMBLE package.  The MCMC specification for a model generated from the following model code will serve as our example for application of all samplers.

<<demoModel, eval=FALSE>>=
code <- nimbleCode({
    a ~ dgamma(1, 1)
    b ~ dgamma(1, 1)
    p ~ dbeta(a, b)
    y1 ~ dbinom(prob = p, size = 10)
    y2 ~ dbinom(prob = p, size = 20)
})
@

\subsection{Terminal node \nm{end} Sampler}
The \nm{end} sampler is only appropriate for use on terminal stochastic nodes (that is, those having no stochastic dependencies).  This sampler functions by calling the \cd{simulate()} method of relevent node, then updating model probabilities, deterministic dependent nodes, and internal MCMC state variables.  The application of an \nm{end} sampler to any non-terminal node will result in invalid posterior inferences.  The \nm{end} sampler will automatically be assigned to all terminal, non-data stochastic nodes in a model by the default MCMC specification, so it is uncommon to manually assign this sampler.

The \nm{end} sampler accepts only a single control list element:
\begin{description}
\item[targetNode] The name of the node on which to operate. This is a required element with no default.
\end{description}

Example usage:
<<terminal-sampler, eval=FALSE>>=
mcmcspec$addSampler(type = 'end',
     control = list(targetNode = 'y1'))
@

\subsection{Scalar Metropolis-Hastings random walk \nm{RW} sampler}
The \nm{RW} sampler executes the Metropolis-Hastings algorithm, with a normal proposal distribution.  This sampler is optionally adaptive, this behavior being controlled by a control list element.  When adaptive, the \cd{scale} (proposal standard deviation) adapts throughout the course of the MCMC execution, to achieve a desirable acceptance rate.  This sampler may be applied to any scalar continuous-valued stochastic model node.

The \nm{RW} sampler accepts the following control list elements:
\begin{description}
\item[targetNode] The name of the scalar node on which to operate. This is a required element with no default.
\item[adaptive (default = \cd{TRUE})] A logical argument, specifying whether or not the sampler should adapt the \cd{scale} (proposal standard deviation) throughout the course of MCMC execution.
\item[adaptInterval (default = 200)] The interval on which to perform adaptation.  Every \cd{adaptInterval} MCMC iterations, the \cd{RW} sampler will perform its adaptation procedure.  This updates the \cd{scale} variable, based upon the sampler's achieved acceptance rate over the past \cd{adaptInterval} iterations.
\item[scale (default = 1)] The initial value of the normal proposal standard deviation.  If \cd{adaptive = FALSE}, \cd{scale} will never change.
\end{description}

Example usage:
<<RW-sampler, eval=FALSE>>=
mcmcspec$addSampler(type = 'RW', 
     control = list(targetNode = 'a', adaptive = FALSE, scale = 3))

mcmcspec$addSampler(type = 'RW',
     control = list(targetNode = 'b', adaptive = TRUE, adaptInterval = 200))
@

Note that because we use a simple normal proposal distribution on all nodes, negative proposals may be simulated for non-negative random variables. These will be rejected, so the only downsides to this are some inefficiency and the presence of warnings in your R session indicating \cd{NA} or \cd{NaN} values. 

\subsection{Multivariate Metropolis-Hastings \nm{RW\_block} sampler}
The \nm{RW\_block} sampler performs a simultaneous update of one or more model nodes, using the Metropolis-Hastings algorithm with a multivarite normal proposal distribution.  This sampler is optionally adaptive, which causes \cd{scale} to adapt throughout the course of the MCMC execution to achieve a desirable acceptance rate, and the \cd{propCov} (multivariate normal proposal covariance matrix) to adapt to emulate the empirical covariance of the sampled nodes, calculated from the MCMC samples.  In addition, the adaptation routine may be specified to \emph{only} adapt the proposal \cd{scale}, but not the proposal covariance matrix.  This sampler may be applied to any set of continuous-valued model nodes, to any single continuous-valued multivariate model node, or to any combination thereof.

The \nm{RW\_block} sampler accepts the following control list elements:
\begin{description}
\item[targetNodes] A character vetor of model nodes or variables, on which the multivariate sampling will operate.  This is a required element with no default.
\item[adaptive (default = \cd{TRUE})] A logical argument, specifying whether or not the sampler should adapt the \cd{scale} and \cd{propCov} (multivariate normal proposal covariance matrix) throughout the course of MCMC execution.  If only the \cd{scale} should undergo adaptation, this argument should be specified as \cd{TRUE}.
\item[adaptScaleOnly (default = \cd{FALSE})] A logical argument.  This argument is only relevant when \cd{adaptive = TRUE}.  When this argument is \cd{FALSE}, both \cd{scale} and \cd{propCov} undergo adaptation; the sampler tunes the scaling to achieve an optimal acceptance rate, and the proposal covariance to mimic that of the empirical samples.  When this argument is \cd{TRUE} and \cd{adaptive = TRUE}, only the proposal \cd{scale} is adapted.  This allows for specification of a fixed proposal covariance matrix.
\item[adaptInterval (default = 200)] The interval on which to perform adaptation.  Every \cd{adaptInterval} MCMC iterations, the \cd{RW\_block} sampler will perform its adaptation procedure.  This updates the \cd{scale} variable, based upon the sampler's achieved acceptance rate over the past \cd{adaptInterval} MCMC iterations, and updates the \cd{propCov} variable towards the empirical covariance of \cd{targetNodes}.
\item[scale (default = 1)] The initial value of the scalar multiplier for \cd{propCov}.  If \cd{adaptive = FALSE}, \cd{scale} will never change.
\item[propCov (default = ``identity'')] The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string \cd{``identity''}, in which case the identity matrix of the appropriate dimension will be used for the initial proposal covariance matrix.  Alternatively, this element may be provided as any positive definite matrix of the appropriate dimensions.
\end{description}

Example usage:
<<block-sampler, eval=FALSE>>=
mcmcspec$addSampler(type = 'RW_block',
     control = list(targetNodes = c('a', 'b')))
@

\subsection{Slice sampler}
The \nm{slice} sampler performs slice sampling of the scalar node to which it is applied.  This is a particular useful sampler, since it can operate on either continuous-valued or discrete-valued scalar nodes.  The slice sampler performs a "stepping out" procedure, in which the slice is iteratively expanded to the left or right by an amount \cd{sliceWidth}.  When sampling from the posterior slice, a ``shrinkage'' procedure is employed to improve sampling efficiency.  This sampler is optionally adaptive, governed by a control list element, whereby the value of \cd{sliceWidth} is adapted towards the observed absolute difference between successive samples.

The \nm{slice} sampler accepts the following control list elements:
\begin{description}
\item[targetNode] The name of the scalar node on which to operate.  This is a required element with no default.
\item[adaptive (default = \cd{TRUE})] A logical argument, specifying whether or not the sampler will adapt the value of \cd{sliceWidth} throughout the course of MCMC execution.
\item[adaptInterval (default = 200)] The interval on which to perform adaptation.
\item[sliceWidth (default = 1)] The initial value of the width of each slice, and also the width of the expansion during the iterative ``stepping out'' procedure.
\item[sliceMaxSteps (default = 100)] The maximum number of expansions which may occur during the ``stepping out'' procedure.
\end{description}

Example usage:
<<slice-sampler, eval=FALSE>>=
mcmcspec$addSampler(type = 'slice', control = list(targetNode = 'y1', 
                                  adaptive = FALSE, sliceWidth = 3))

mcmcspec$addSampler(type = 'slice', control = list(targetNode = 'y2', 
                               adaptive = TRUE, sliceMaxSteps = 1))
@

\subsection{Hierarchical \nm{crossLevel} sampler}
This sampler is constructed to perform simultaneous updates across two levels of stochastic dependence in the model structure.  This is possible when all stochastic dependents of the top-level nodes appear in conjugate relationships.  In this situation, a Metropolis-Hastings algorithm may be used, in which a multivariate normal proposal distribution is used for the top-level nodes, and the corresponding proposals for the lower-level nodes are determined using their conjugate relationships.  The joint proposal for the top-level and lower-level nodes is either accepted or rejected, based upon the Metropolis-Hastings ratio. 


The \nm{crossLevel} sampler accepts the following control list elements:
\begin{description}
\item[topNodes] A character vetor of model nodes or variables, for which the multivariate normal proposal distribution will be used.  All stochastic dependents of \cd{topNodes} must appear in conjugate relationships in the model structure.  This requirement is checked at the time of building the MCMC, and will produce an error if not satisfied.  This is a required element with no default.
\item[adaptive (default = \cd{TRUE})] Logical argument, dictates the adaptation of the multivariate normal proposal distribution on \cd{topNodes}.
\item[adaptInterval (default = 200)] The interval on which to perform adaptation.
\item[scale (default = 1)] The initial value of the scalar multiplier for \cd{propCov}.
\item[propCov (default = ``identity'')] The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the character string \cd{``identity''}, or any positive definite matrix of the appropriate dimensions.
\end{description}

Example usage:
<<crossLevel-sampler, eval=FALSE>>=
mcmcspec$addSampler(type = 'crossLevel',
     control = list(topNodes = c('a', 'b')))
@

Note that this sampler amounts to sampling from the marginal posterior distribution of the top-level nodes, having integrated over the lower-level nodes, without having to analytically integrate over those nodes. This sampler is useful when there is strong dependence across the levels of a model that causes problems with convergence or mixing.


 \subsection{\nm{RW\_llFunction} sampler using a specified log-likelihood function}
 
 The \nm{RW\_llFunction} sampler performs a Metropolis-Hastings algorithm using a normal proposal distribution.  However, the log-likelihood of the dependent nodes is calculated using a log-likelihood function (\cd{llFunction}) which is provided as a control list element.  The \cd{llFunction} for calculating log-likelihoods must accurately produce the total log-likelihood for all stochastic dependent nodes of \cd{targetNode}, optionally including the log-likelihood of \cd{targetNode} itself; if not, incorrect inferences will result.  This sampler is useful when the model likelihood can be directly calculated through analytical integration over latent model nodes.  In this case, the log-likelihood function can be implemented as a nimbleFunction, and used to instantiate this sampler.
 
 \begin{description}
 \item[targetNode] The name of the scalar node on which to operate.  This is a required element with no default.
\item[adaptive (default = \cd{TRUE})] A logical argument, specifying whether or not the sampler should adapt the \cd{scale} (proposal standard deviation) throughout the course of MCMC execution.
\item[adaptInterval (default = 200)] The interval on which to perform adaptation.
\item[scale (default = 1)] The initial value of the normal proposal standard deviation.
 \item[llFunction] A specialized nimbleFunction, which accepts no arguments, and has return value equal to the total log-likelihood for all stochastic dependents of \cd{topNodes}, given the current values of all model nodes.  Optionally, the return value of \cd{llFunction} may also include the log-likelihood associated with \cd{targetNode}.  This behavior is dictated by the control list element \cd{includesTarget}.  This is a required element with no default.
 \item[includesTarget] Logical variable.  If \cd{TRUE}, the return value of \cd{llFunction} must include the log-likelihood for \cd{targetNode}.  If \cd{FALSE}, the return value of \cd{llFunction} must not include the log-likelihood for \cd{targetNode}. This is a required element with no default.
 \end{description}

Example usage:
 <<RW_ll, eval=FALSE>>=
 mcmcspec$addSampler(type = 'RW_llFunction',
     control = list(targetNode = 'p', llFunction = logLiky1y2, includesTarget = FALSE))
 @

\subsection{Conjugate samplers}
Conjugate sampler functions are provided for nodes in conjugate relationships, as specified by the system-level \cd{conjugacyRelationshipsInputList}.  Conjugate samplers should not, in general, be manually added or modified by a user, since the control list requisites and syntax are lengthy, and determing conjugacy and assigning conjugate samplers is fully handled by the default MCMC specification.

In this release, conjugacies involving multivariate distributions as well as some additional conjugate relationships are not detected.


\section{Detailed MCMC example: \nm{litters}}
\label{sec:mcmc-example-litters}

The following is a self-contained full example of specifying, building, compiling, and running two MCMC algorithms.  We use the \nm{litters} example from the BUGS examples.

<<MCMC-litters>>=

###############################
##### model specification #####
###############################

## define our model using BUGS syntax
litters_code <- nimbleCode({
    for (i in 1:G) {
        a[i] ~ dgamma(1, .001)
        b[i] ~ dgamma(1, .001)
        for (j in 1:N) {
            r[i,j] ~ dbin(p[i,j], n[i,j])
            p[i,j] ~ dbeta(a[i], b[i]) 
        }
        mu[i] <- a[i] / (a[i] + b[i])
        theta[i] <- 1 / (a[i] + b[i])
    }
})

## list of fixed constants
constants <- list(G = 2,
                  N = 16,
                  n = matrix(c(13, 12, 12, 11, 9, 10, 9,  9, 8, 11, 8, 10, 13,
                      10, 12, 9, 10,  9, 10, 5,  9,  9, 13, 7, 5, 10, 7,  6, 
                      10, 10, 10, 7), nrow = 2))

## list specifying model data
data <- list(r = matrix(c(13, 12, 12, 11, 9, 10,  9, 9, 8, 10, 8, 9, 12, 9,
                 11, 8, 9,  8,  9,  4, 8,  7, 11, 4, 4, 5 , 5, 3,  7, 3, 
                 7, 0), nrow = 2))

## list specifying initial values
inits <- list(p = matrix(0.5, nrow = 2, ncol = 16))

## build the R model object
Rmodel <- nimbleModel(litters_code,
                      constants = constants,
                      data      = data,
                      inits     = inits)


###########################################
##### MCMC specification and building #####
###########################################

## generate the default MCMC specification;
## only wish to monitor the derived quantity 'mu'
mcmcspec <- configureMCMC(Rmodel, monitors = 'mu')

## check the samplers assigned by default MCMC specification
mcmcspec$getSamplers()

## double-check our monitors, and thinning interval
mcmcspec$getMonitors()

## build the executable R MCMC function
mcmc <- buildMCMC(mcmcspec)

## let's try another MCMC, as well,
## this time using the crossLevel sampler for top-level nodes

## generate an empty MCMC specification
## we need a new copy of the model to avoid compilation errors
Rmodel2 <- Rmodel$newModel()
mcmcspec_CL <- configureMCMC(Rmodel2, nodes = NULL, monitors = 'mu')

## add two crossLevel samplers
mcmcspec_CL$addSampler(type = 'crossLevel',
     control = list(topNodes = c('a[1]', 'b[1]')))

mcmcspec_CL$addSampler(type = 'crossLevel',
     control = list(topNodes = c('a[2]', 'b[2]')))

## let's check the samplers
mcmcspec_CL$getSamplers()

## build this second executable R MCMC function
mcmc_CL <- buildMCMC(mcmcspec_CL)


###################################
##### compile to C++, and run #####
###################################

## compile the two copies of the model
Cmodel <- compileNimble(Rmodel)
Cmodel2 <- compileNimble(Rmodel2)

## compile both MCMC algorithms, in the same
## project as the R model object
## NOTE: at this time, we recommend compiling ALL
## executable MCMC functions together
Cmcmc <- compileNimble(mcmc, project = Rmodel)
Cmcmc_CL <- compileNimble(mcmc_CL, project = Rmodel2)

## run the default MCMC function,
## and example the mean of mu[1]
Cmcmc$run(1000)
cSamplesMatrix <- as.matrix(Cmcmc$mvSamples)
mean(cSamplesMatrix[, 'mu[1]'])

## run the crossLevel MCMC function,
## and examine the mean of mu[1]
Cmcmc_CL$run(1000)
cSamplesMatrix_CL <- as.matrix(Cmcmc_CLmvSamples)
mean(cSamplesMatrix_CL[, 'mu[1]'])
@


\section{Higher level usage: MCMC Suite}

This section introduces the higher level MCMC analysis capabilities of the MCMC Suite.  We re-analyze the same \nm{litters} example from Section \ref{sec:mcmc-example-litters}, using an MCMC Suite.  Subsequently, additional details of the Suite are given.

\subsection{MCMC Suite example: \nm{litters}}

The following code executes the following MCMC algorithms on the \nm{litters} example:
\begin{enumerate}
\item WinBUGS
\item JAGS
\item NIMBLE default specification
\item NIMBLE specification with argument \cd{onlySlice = TRUE}
\item NIMBLE custom specification using two crossLevel samplers
\end{enumerate}

<<MCMCsuite, eval=FALSE>>=
litters_suite <- MCMCsuite(
    model = litters_code,
    constants = constants,
    data = data,
    inits = inits,
    monitors = 'mu',
    MCMCs = c('bugs', 'jags', 'nimble', 'nimble_slice', 'nimble_CL'),
    MCMCdefs = list(
        nimble_CL = quote({
            mcmcspec <- configureMCMC(Rmodel, nodes = NULL)
            mcmcspec$addSampler(type = 'crossLevel', control = list(topNodes = c('a[1]', 'b[1]')))
            mcmcspec$addSampler(type = 'crossLevel', control = list(topNodes = c('a[2]', 'b[2]')))
            mcmcspec
        })),
    plotName = 'littersSuite'
)

output <- litters_suite$output
@

\subsection{MCMC Suite outputs}

Executing the MCMC Suite generates a single \cd{output} variable, which is a named list containing three objects, as well as several plots.

\subsubsection{Samples}

\cd{output\$samples} is a three-dimensional array, containing all MCMC samples from each algorithm.  The first dimension of the \cd{samples} array corresponds to each MCMC algorithm, and may be indexed by the name of the algorithm.  The second dimension of the \cd{samples} array corresponds to each node which was monitored, and may be indexed by the node name.  The third dimension of \cd{samples} contains the MCMC samples, and has length \cd{niter/thin}.

\subsubsection{Summary}

The MCMC suite output contains a variety of pre-computed summary statistics, which are stored in the \cd{output\$summary} matrix.  For each monitored node and each MCMC algorithm, the following default summary statistics are calculated: \nm{mean}, \nm{median}, \nm{sd}, the 2.5\% quantile, and the 97.5\% quantile.  These summary statistics are easily viewable, as:


\begin{verbatim}
litters_suite$output$summary
# , , mu[1]
#                   mean    median         sd  quant025  quant975
# bugs         0.8795868 0.8889000 0.04349589 0.7886775 0.9205025
# jags         0.8872778 0.8911989 0.02911325 0.8287991 0.9335317
# nimble       0.8562232 0.8983763 0.12501395 0.4071524 0.9299781
# nimble_slice 0.8975283 0.9000483 0.02350363 0.8451926 0.9367147
# nimble_CL    0.8871314 0.8961146 0.05243039 0.7640730 0.9620532
# 
# , , mu[2]
#                   mean    median         sd  quant025  quant975
# bugs         0.7626974 0.7678000 0.04569705 0.6745975 0.8296025
# jags         0.7635539 0.7646913 0.03803033 0.6824946 0.8313314
# nimble       0.7179094 0.7246935 0.06061116 0.6058669 0.7970130
# nimble_slice 0.7665562 0.7683093 0.04051432 0.6641368 0.8350716
# nimble_CL    0.7605938 0.7655945 0.09138471 0.5822785 0.9568195
\end{verbatim}

\subsubsection{Timing}

\cd{output\$timing} contains a named vector of timing information for each algorithm, and the compile time for NIMBLE (in minutes).

\subsubsection{Plots}

Executing the MCMC Suite provides and saves several plots.  These include traceplots and posterior density plots for each monitored node, under each algorithm.

Note that the generation of MCMC Suite plots \emph{specifically in Rstudio} may result in several warning messages from R (regarding graphics devices), but will function without any problems.

\subsection{Custom arguments to MCMC Suite}

An MCMC Suite is highly customizable, in terms of all of the following:
\begin{itemize}
\item Nodes to monitor
\item Number of MCMC iterations
\item Thinning interval
\item Burn-in
\item Summary statistics
\item MCMC algorithms
\end{itemize}

\subsubsection{argument: \cd{monitors}}

Character vector specifying the nodes and/or vectors to monitor.

\subsubsection{argument: \cd{niter}}

Integer specifying the number of MCMC iterations to run.

\subsubsection{argument: \cd{thin}}

Integer specifying the thinning interval.

\subsubsection{argument: \cd{burnin}}

Integer specifying the number of samples to discard from all chains of MCMC samples.  Samples are discarded prior to thinning.

\subsubsection{argument: \cd{summaryStats}}

A character vector, providing the name of any function which operates on a numeric vector, and returns a numeric scalar.  Likewise, a character string defining such a function is admissible, for example \cd{'function(x) mean(abs(x))'}.  The default value for \cd{summaryStats} is the set: \cd{mean}, \cd{median}, \cd{sd}, the 2.5\% quantile, and the 97.5\% quantile.

\subsubsection{argument: \cd{MCMCs}}

A character vector, defining the MCMC algorithms to run.  The default value for \text{MCMCs} includes the following algorithms:
\begin{description}
\item[\cd{`bugs'}] The standard WinBUGS algorithm
\item[\cd{`jags'}] The standard JAGS algorithm
\item[\cd{`nimble'}] NIMBLE using the default specification
\item[\cd{`nimble\_RW'}] NIMBLE using the default specification with \cd{onlyRW = TRUE}
\item[\cd{`nimble\_slice'}] NIMBLE using the default MC specification with \cd{onlySlice= TRUE}
\end{description}

The names of additional, custom, MCMC algorithms may also be provided in the \cd{MCMCs} argument, so long as these custom algorithms are defined in the \cd{MCMCdefs} argument.  An example of this usage was given with the \cd{crossLevel} algorithm in the \nm{litters} MCMC Suite example.

\subsubsection{argument: \cd{MCMCdefs}}

A named list of definitions, for any custom MCMC algorithms specified in the \cd{MCMCs} argument.  If \cd{MCMCs} specified an algorithm called \cd{`myMCMC'}, then \cd{MCMCdefs} must contain an element named \cd{`myMCMC'}.  The contents of this element must be a block of code that, when executed, returns the desired MCMC specification object.  This block of code may assume the existence of the R model object, \cd{Rmodel}.  Further, this block of code need not worry about adding monitors to the MCMC specification; it need only specify the samplers.

As a final important point, execution of this block of code must \emph{return} the MCMC specification object.  Therefore, elements supplied in the \cd{MCMCdefs} argument should usually take the form:

<<MCMCdefs, eval=FALSE>>=
MCMCdefs = list(
     myMCMC = quote({
          mcmcspec <- configureMCMC(Rmodel, ....)
          mcmcspec$addSampler(.....)
          mcmcspec     ## returns the MCMC specification object
     })
)
@

\subsubsection{argument: \cd{bugs\_directory}}

A character string giving the path to the directory containing the WinBUGS executable.  The default value is \cd{'C:/WinBUGS14'}.

\subsubsection{argument: \cd{bugs\_program}}

A character string giving the name of the WiBUGS program to execute.  This will be passed directly to the \cd{bugs()} function.  The default value is \cd{'WinBUGS'}.

\subsubsection{argument: \cd{makePlot}}

A logical specifying whether to generate the traceplots and posterior density plots.  Default value is \cd{TRUE}.

\subsubsection{argument: \cd{savePlot}}

A logical specifying whether to save the generated plots.  Only used if \cd{makePlot = TRUE}.  Default value is \cd{TRUE}.

\subsubsection{argument: \cd{plotName}}

A character string giving the filename for saving plots.  Only used if \cd{savePlot = TRUE}.  Default value is \cd{'MCMCsuite'}.



\section{Advanced topics}

\subsection{Custom sampler functions}

The following code illustrates how a NIMBLE developer would concisely implement, and instantiate a Metropolis-Hastings random walk sampler with fixed proposal standard deviation.  The comments accompanying the code explain the necessary characteristics of all sampler functions.

<<custom-sampler, eval=FALSE>>=
## the names of sampler functions must begin with 'sampler_'.
## the name of this sampler function, for the purposes of 
## adding it to MCMC specifications, will be 'myRW'
sampler_myRW <- nimbleFunction(

    ## sampler functions must contain 'sampler_BASE'
    contains = sampler_BASE,
    
    ## sampler functons must have exactly these setup arguments:
    ## model, mvSaved, control
    setup = function(model, mvSaved, control) {
        ## first, extract the control list elements, which will
        ## dictate the behavior of this sampler.
        ## the setup code will be later processed to determine
        ## all named elements extracted from the control list.
        ## these will become the required elements for any 
        ## control list argument to this sampler, unless they also
        ## appear in the system-level variable 'controlDefaultList'
        
        ## the name of the scalar node which we'll sample
        targetNode <- control$targetNode
        
        ## the random walk proposal standard deviation
        scale <- control$scale
        
        ## determine the list of all dependent nodes,
        ## up to the first layer of stochastic nodes, generally
        ## called 'calcNodes'.  The values, inputs, and logProbs
        ## of these nodes will be retrieved and/or altered
        ## by this algorithm.
        calcNodes <- model$getDependencies(targetNode)
    },
    
    ## the run function must accept no arguments, execute 
    ## the sampling algorithm, leave the modelValues object
    ## 'mvSaved' as an exact copy of the updated values in model,
    ## and have no return value.  initially, mvSaved contains
    ## an exact copy of the values and logProbs in the model.
    run = function() {
        
        ## extract the initial model logProb
        model_lp_initial <- getLogProb(model, calcNodes)
        
        ## generate a proposal value for targetNode
        proposal <- rnorm(1, model[[targetNode]], scale)
        
        ## store this proposed value into targetNode.
        ## notice the double assignment operator, `<<-`,
        ## necessary because 'model' is a persistant member
        ## data object of this sampler.
        model[[targetNode]] <<- proposal
        
        ## calculate targetNode_logProb, propogate the 
        ## proposed value through any deterministic dependents,
        ## and calculate the logProb for any stochastic
        ## dependnets.  The total (sum) logProb is returned.
        model_lp_proposed <- calculate(model, calcNodes)
        
        ## calculate the log Metropolis-Hastings ratio
        log_MH_ratio <- model_lp_proposed - model_lp_initial
        
        ## Metropolis-Hastings step: determine whether or
        ## not to accept the newly proposed value
        u <- runif(1, 0, 1)
        if(u < exp(log_MH_ratio)) jump <- TRUE
        else                      jump <- FALSE
        
        ## if we accepted the proposal, then store the updated
        ## values and logProbs from 'model' into 'mvSaved'.
        ## if the proposal was not accepted, restore the values
        ## and logProbs from 'mvSaved' back into 'model'.
        if(jump) nimCopy(from = model, to = mvSaved, row = 1, 
                         nodes = calcNodes, logProb = TRUE)
        else     nimCopy(from = mvSaved, to = model, row = 1,
                         nodes = calcNodes, logProb = TRUE)
    },
    
    ## sampler functions must have a member method 'reset',
    ## which takes no arguments and has no return value.
    ## this function is used to reset the sampler to its
    ## initial state.  since this sampler function maintains
    ## no internal member data variables, reset() needn't
    ## do anything.
    methods = list(
        reset = function () {}
    )
)

## now, assume the existence of an R model object 'Rmodel',
## which has a scalar-valued stochastic node 'x'

## create an MCMC specification with no sampler functions
mcmcspec <- configureMCMC(Rmodel, nodes = NULL)

## add our custom-build random walk sampler on node 'x',
## with a fixed proposal standard deviation = 0.1
mcmcspec$addSampler(type = 'myRW',
     control = list(targetNode = 'x', scale = 0.1))

Rmcmc <- buildMCMC(mcmcspec)   ## etc...
@








